source code,label
"  public InternalCache getCacheForProcessingClientRequests() {
    return cacheForClients;
  }",True
"  public InternalCacheForClientAccess getCacheForProcessingClientRequests() {
    return cacheForClients;
  }",False
"  private GemFireCacheImpl(boolean isClient, PoolFactory pf, InternalDistributedSystem system,
      CacheConfig cacheConfig, boolean asyncEventListeners, TypeRegistry typeRegistry) {
    this.isClient = isClient;
    this.poolFactory = pf;
    this.cacheConfig = cacheConfig; // do early for bug 43213
    this.pdxRegistry = typeRegistry;

    // Synchronized to prevent a new cache from being created
    // before an old one has finished closing
    synchronized (GemFireCacheImpl.class) {

      // start JTA transaction manager within this synchronized block
      // to prevent race with cache close. fixes bug 43987
      JNDIInvoker.mapTransactions(system);
      this.system = system;
      this.dm = this.system.getDistributionManager();

      if (!isClient) {
        this.configurationResponse = requestSharedConfiguration();

        // apply the cluster's properties configuration and initialize security using that
        // configuration
        ccLoader.applyClusterPropertiesConfiguration(this.configurationResponse,
            this.system.getConfig());

        this.securityService =
            SecurityServiceFactory.create(this.system.getConfig().getSecurityProps(), cacheConfig);
        this.system.setSecurityService(this.securityService);
      } else {
        // create a no-op security service for client
        this.securityService = SecurityServiceFactory.create();
      }

      if (!this.isClient && PoolManager.getAll().isEmpty()) {
        // We only support management on members of a distributed system
        // Should do this: if (!getSystem().isLoner()) {
        // but it causes quickstart.CqClientTest to hang
        this.resourceEventsListener = new ManagementListener(this.system);
        this.system.addResourceListener(this.resourceEventsListener);
        if (this.system.isLoner()) {
          this.system.getInternalLogWriter()
              .info(""Running in local mode since no locators were specified."");
        }
      } else {
        logger.info(""Running in client mode"");
        this.resourceEventsListener = null;
      }

      // Don't let admin-only VMs create Cache's just yet.
      if (this.dm.getDMType() == ClusterDistributionManager.ADMIN_ONLY_DM_TYPE) {
        throw new IllegalStateException(
            ""Cannot create a Cache in an admin-only VM."");
      }

      this.rootRegions = new HashMap<>();

      this.cqService = CqServiceProvider.create(this);

      // Create the CacheStatistics
      this.cachePerfStats = new CachePerfStats(system);
      CachePerfStats.enableClockStats = this.system.getConfig().getEnableTimeStatistics();

      this.transactionManager = new TXManagerImpl(this.cachePerfStats, this);
      this.dm.addMembershipListener(this.transactionManager);

      this.creationDate = new Date();

      this.persistentMemberManager = new PersistentMemberManager();

      if (asyncEventListeners) {
        this.eventThreadPool = LoggingExecutors.newThreadPoolWithFixedFeed(""Message Event Thread"",
            command -> {
              ConnectionTable.threadWantsSharedResources();
              command.run();
            }, EVENT_THREAD_LIMIT, this.cachePerfStats.getEventPoolHelper(), 1000,
            getThreadMonitorObj(),
            EVENT_QUEUE_LIMIT);
      } else {
        this.eventThreadPool = null;
      }

      // Initialize the advisor here, but wait to exchange profiles until cache is fully built
      this.resourceAdvisor = ResourceAdvisor.createResourceAdvisor(this);

      // Initialize the advisor here, but wait to exchange profiles until cache is fully built
      this.jmxAdvisor = JmxManagerAdvisor.createJmxManagerAdvisor(new JmxManagerAdvisee(this));

      this.resourceManager = InternalResourceManager.createResourceManager(this);
      this.serialNumber = DistributionAdvisor.createSerialNumber();

      getInternalResourceManager().addResourceListener(ResourceType.HEAP_MEMORY, getHeapEvictor());

      /*
       * Only bother creating an off-heap evictor if we have off-heap memory enabled.
       */
      if (null != getOffHeapStore()) {
        getInternalResourceManager().addResourceListener(ResourceType.OFFHEAP_MEMORY,
            getOffHeapEvictor());
      }

      this.recordedEventSweeper = createEventTrackerExpiryTask();
      this.tombstoneService = TombstoneService.initialize(this);

      TypeRegistry.init();
      basicSetPdxSerializer(this.cacheConfig.getPdxSerializer());
      TypeRegistry.open();

      if (!isClient()) {
        // Initialize the QRM thread frequency to default (1 second )to prevent spill
        // over from previous Cache , as the interval is stored in a static
        // volatile field.
        HARegionQueue.setMessageSyncInterval(HARegionQueue.DEFAULT_MESSAGE_SYNC_INTERVAL);
      }
      FunctionService.registerFunction(new PRContainsValueFunction());
      this.expirationScheduler = new ExpirationScheduler(this.system);

      // uncomment following line when debugging CacheExistsException
      if (DEBUG_CREATION_STACK) {
        this.creationStack = new Exception(
            String.format(""Created GemFireCache %s"", toString()));
      }

      this.txEntryStateFactory = TXEntryState.getFactory();
      if (XML_PARAMETERIZATION_ENABLED) {
        // If product properties file is available replace properties from there
        Properties userProps = this.system.getConfig().getUserDefinedProps();
        if (userProps != null && !userProps.isEmpty()) {
          this.resolver = new CacheXmlPropertyResolver(false,
              PropertyResolver.NO_SYSTEM_PROPERTIES_OVERRIDE, userProps);
        } else {
          this.resolver = new CacheXmlPropertyResolver(false,
              PropertyResolver.NO_SYSTEM_PROPERTIES_OVERRIDE, null);
        }
      } else {
        this.resolver = null;
      }

      SystemFailure.signalCacheCreate();

      this.diskMonitor = new DiskStoreMonitor(system.getConfig().getLogFile());

      addRegionEntrySynchronizationListener(new GatewaySenderQueueEntrySynchronizationListener());
      backupService = new BackupService(this);
    } // synchronized
  }",True
"  private GemFireCacheImpl(boolean isClient, PoolFactory pf, InternalDistributedSystem system,
      CacheConfig cacheConfig, boolean asyncEventListeners, TypeRegistry typeRegistry) {
    this.isClient = isClient;
    this.poolFactory = pf;
    this.cacheConfig = cacheConfig; // do early for bug 43213
    this.pdxRegistry = typeRegistry;

    // Synchronized to prevent a new cache from being created
    // before an old one has finished closing
    synchronized (GemFireCacheImpl.class) {

      // start JTA transaction manager within this synchronized block
      // to prevent race with cache close. fixes bug 43987
      JNDIInvoker.mapTransactions(system);
      this.system = system;
      this.dm = this.system.getDistributionManager();

      if (!isClient) {
        this.configurationResponse = requestSharedConfiguration();

        // apply the cluster's properties configuration and initialize security using that
        // configuration
        ccLoader.applyClusterPropertiesConfiguration(this.configurationResponse,
            this.system.getConfig());

        this.securityService =
            SecurityServiceFactory.create(this.system.getConfig().getSecurityProps(), cacheConfig);
        this.system.setSecurityService(this.securityService);
      } else {
        // create a no-op security service for client
        this.securityService = SecurityServiceFactory.create();
      }

      if (!this.isClient && PoolManager.getAll().isEmpty()) {
        // We only support management on members of a distributed system
        // Should do this: if (!getSystem().isLoner()) {
        // but it causes quickstart.CqClientTest to hang
        this.resourceEventsListener = new ManagementListener(this.system);
        this.system.addResourceListener(this.resourceEventsListener);
        if (this.system.isLoner()) {
          this.system.getInternalLogWriter()
              .info(""Running in local mode since no locators were specified."");
        }
      } else {
        logger.info(""Running in client mode"");
        this.resourceEventsListener = null;
      }

      // Don't let admin-only VMs create Cache's just yet.
      if (this.dm.getDMType() == ClusterDistributionManager.ADMIN_ONLY_DM_TYPE) {
        throw new IllegalStateException(
            ""Cannot create a Cache in an admin-only VM."");
      }

      this.rootRegions = new HashMap<>();

      this.cqService = CqServiceProvider.create(this);

      // Create the CacheStatistics
      this.cachePerfStats = new CachePerfStats(system);
      CachePerfStats.enableClockStats = this.system.getConfig().getEnableTimeStatistics();

      this.transactionManager = new TXManagerImpl(this.cachePerfStats, this);
      this.dm.addMembershipListener(this.transactionManager);

      this.creationDate = new Date();

      this.persistentMemberManager = new PersistentMemberManager();

      if (asyncEventListeners) {
        this.eventThreadPool = LoggingExecutors.newThreadPoolWithFixedFeed(""Message Event Thread"",
            command -> {
              ConnectionTable.threadWantsSharedResources();
              command.run();
            }, EVENT_THREAD_LIMIT, this.cachePerfStats.getEventPoolHelper(), 1000,
            getThreadMonitorObj(),
            EVENT_QUEUE_LIMIT);
      } else {
        this.eventThreadPool = null;
      }

      // Initialize the advisor here, but wait to exchange profiles until cache is fully built
      this.resourceAdvisor = ResourceAdvisor.createResourceAdvisor(this);

      // Initialize the advisor here, but wait to exchange profiles until cache is fully built
      this.jmxAdvisor = JmxManagerAdvisor
          .createJmxManagerAdvisor(new JmxManagerAdvisee(getCacheForProcessingClientRequests()));

      this.resourceManager = InternalResourceManager.createResourceManager(this);
      this.serialNumber = DistributionAdvisor.createSerialNumber();

      getInternalResourceManager().addResourceListener(ResourceType.HEAP_MEMORY, getHeapEvictor());

      /*
       * Only bother creating an off-heap evictor if we have off-heap memory enabled.
       */
      if (null != getOffHeapStore()) {
        getInternalResourceManager().addResourceListener(ResourceType.OFFHEAP_MEMORY,
            getOffHeapEvictor());
      }

      this.recordedEventSweeper = createEventTrackerExpiryTask();
      this.tombstoneService = TombstoneService.initialize(this);

      TypeRegistry.init();
      basicSetPdxSerializer(this.cacheConfig.getPdxSerializer());
      TypeRegistry.open();

      if (!isClient()) {
        // Initialize the QRM thread frequency to default (1 second )to prevent spill
        // over from previous Cache , as the interval is stored in a static
        // volatile field.
        HARegionQueue.setMessageSyncInterval(HARegionQueue.DEFAULT_MESSAGE_SYNC_INTERVAL);
      }
      FunctionService.registerFunction(new PRContainsValueFunction());
      this.expirationScheduler = new ExpirationScheduler(this.system);

      // uncomment following line when debugging CacheExistsException
      if (DEBUG_CREATION_STACK) {
        this.creationStack = new Exception(
            String.format(""Created GemFireCache %s"", toString()));
      }

      this.txEntryStateFactory = TXEntryState.getFactory();
      if (XML_PARAMETERIZATION_ENABLED) {
        // If product properties file is available replace properties from there
        Properties userProps = this.system.getConfig().getUserDefinedProps();
        if (userProps != null && !userProps.isEmpty()) {
          this.resolver = new CacheXmlPropertyResolver(false,
              PropertyResolver.NO_SYSTEM_PROPERTIES_OVERRIDE, userProps);
        } else {
          this.resolver = new CacheXmlPropertyResolver(false,
              PropertyResolver.NO_SYSTEM_PROPERTIES_OVERRIDE, null);
        }
      } else {
        this.resolver = null;
      }

      SystemFailure.signalCacheCreate();

      this.diskMonitor = new DiskStoreMonitor(system.getConfig().getLogFile());

      addRegionEntrySynchronizationListener(new GatewaySenderQueueEntrySynchronizationListener());
      backupService = new BackupService(this);
    } // synchronized
  }",False
"  public InternalCache getCacheForProcessingClientRequests() {
    return this;
  }",True
"  public InternalCacheForClientAccess getCacheForProcessingClientRequests() {
    return this;
  }",False
"  public <K, V> Region<K, V> createInternalRegion(String name, RegionAttributes<K, V> p_attrs,
      InternalRegionArguments internalRegionArgs)
      throws RegionExistsException, TimeoutException, IOException, ClassNotFoundException {
    return delegate.createVMRegion(name, p_attrs, internalRegionArgs);
  }",False
"  public <K, V> Region<K, V> getInternalRegion(String path) {
    Region<K, V> result = delegate.getRegion(path);
    return result;
  }",True
"  public <K, V> Region<K, V> getInternalRegion(String path) {
    return delegate.getRegion(path);
  }",False
"  public InternalCache getCacheForProcessingClientRequests() {
    throw new UnsupportedOperationException(""Should not be invoked"");
  }",True
"  public InternalCacheForClientAccess getCacheForProcessingClientRequests() {
    throw new UnsupportedOperationException(""Should not be invoked"");
  }",False
"  public static ManagementService getManagementService(Cache cache) {
    return BaseManagementService.getManagementService((InternalCache) cache);
  }",True
"  public static ManagementService getManagementService(Cache cache) {
    return BaseManagementService
        .getManagementService(((InternalCache) cache).getCacheForProcessingClientRequests());
  }",False
"  public Cache getCache() {
    return cache;
  }",True
"  public Cache getCache() {
    if (cache == null) {
      return null;
    }
    return cache.getCacheForProcessingClientRequests();
  }",False
"  public static ManagementService getManagementService(InternalCache cache) {
    synchronized (instances) {
      BaseManagementService service = instances.get(cache);
      if (service == null) {
        service = SystemManagementService.newSystemManagementService(cache);
        instances.put(cache, service);

      }
      return service;
    }
  }",True
"  public static ManagementService getManagementService(InternalCacheForClientAccess cache) {
    synchronized (instances) {
      BaseManagementService service = instances.get(cache);
      if (service == null) {
        service = SystemManagementService.newSystemManagementService(cache);
        instances.put(cache, service);

      }
      return service;
    }
  }",False
"   */
  public static ManagementService getManagementService(InternalCacheForClientAccess cache) {
    synchronized (instances) {
      BaseManagementService service = instances.get(cache);
      if (service == null) {
        service = SystemManagementService.newSystemManagementService(cache);
        instances.put(cache, service);

      }
      return service;
    }",False
"  public static ManagementService getExistingManagementService(InternalCache cache) {
    synchronized (instances) {
      BaseManagementService service = (BaseManagementService) instances.get(cache);
      return service;
    }
  }",True
"  public static ManagementService getExistingManagementService(InternalCache cache) {
    synchronized (instances) {
      BaseManagementService service = instances.get(cache.getCacheForProcessingClientRequests());
      return service;
    }
  }",False
"    public DistributedMember call() {
      synchronized (member) {
        String appender = MBeanJMXAdapter.getUniqueIDForMember(member);
        String monitoringRegionName = ManagementConstants.MONITORING_REGION + ""_"" + appender;
        String notificationRegionName = ManagementConstants.NOTIFICATION_REGION + ""_"" + appender;

        if (cache.getRegion(monitoringRegionName) != null
            && cache.getRegion(notificationRegionName) != null) {
          return member;
        }

        try {

          // GII wont start at all if its interrupted
          if (!Thread.currentThread().isInterrupted()) {

            // as the regions will be internal regions
            InternalRegionArguments internalRegionArguments = new InternalRegionArguments();
            internalRegionArguments.setIsUsedForMetaRegion(true);

            // Create anonymous stats holder for Management Regions
            HasCachePerfStats monitoringRegionStats =
                () -> new CachePerfStats(cache.getDistributedSystem(), ""managementRegionStats"");

            internalRegionArguments.setCachePerfStatsHolder(monitoringRegionStats);

            // Monitoring region for member is created
            AttributesFactory<String, Object> monitorAttributesFactory = new AttributesFactory<>();
            monitorAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
            monitorAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
            monitorAttributesFactory.setConcurrencyChecksEnabled(false);
            ManagementCacheListener managementCacheListener =
                new ManagementCacheListener(proxyFactory);
            monitorAttributesFactory.addCacheListener(managementCacheListener);

            RegionAttributes<String, Object> monitoringRegionAttrs =
                monitorAttributesFactory.create();

            // Notification region for member is created
            AttributesFactory<NotificationKey, Notification> notificationAttributesFactory =
                new AttributesFactory<>();
            notificationAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
            notificationAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
            notificationAttributesFactory.setConcurrencyChecksEnabled(false);

            // Fix for issue #49638, evict the internal region _notificationRegion
            notificationAttributesFactory
                .setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
                    ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));

            NotificationCacheListener notifListener = new NotificationCacheListener(proxyFactory);
            notificationAttributesFactory.addCacheListener(notifListener);

            RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
                notificationAttributesFactory.create();

            boolean proxyMonitoringRegionCreated;

            Region<String, Object> proxyMonitoringRegion;
            try {
              if (!running) {
                return null;
              }
              proxyMonitoringRegion =
                  cache.createVMRegion(monitoringRegionName, monitoringRegionAttrs,
                      internalRegionArguments);
              proxyMonitoringRegionCreated = true;

            } catch (TimeoutException | RegionExistsException | IOException
                | ClassNotFoundException e) {
              if (logger.isDebugEnabled()) {
                logger.debug(""Error During Internal Region creation"", e);
              }
              throw new ManagementException(e);
            }

            boolean proxyNotificationRegionCreated = false;
            Region<NotificationKey, Notification> proxyNotificationRegion;
            try {
              if (!running) {
                return null;
              }
              proxyNotificationRegion =
                  cache.createVMRegion(notificationRegionName, notifRegionAttrs,
                      internalRegionArguments);
              proxyNotificationRegionCreated = true;
            } catch (TimeoutException | RegionExistsException | IOException
                | ClassNotFoundException e) {
              if (logger.isDebugEnabled()) {
                logger.debug(""Error During Internal Region creation"", e);
              }
              throw new ManagementException(e);
            } finally {
              if (!proxyNotificationRegionCreated && proxyMonitoringRegionCreated) {
                // Destroy the proxy region if proxy notification region is not created
                proxyMonitoringRegion.localDestroyRegion();
              }
            }

            if (logger.isDebugEnabled()) {
              logger.debug(""Management Region created with Name : {}"",
                  proxyMonitoringRegion.getName());
              logger.debug(""Notification Region created with Name : {}"",
                  proxyNotificationRegion.getName());
            }

            // Only the exception case would have destroyed the proxy
            // regions. We can safely proceed here.
            repo.putEntryInMonitoringRegionMap(member, proxyMonitoringRegion);
            repo.putEntryInNotifRegionMap(member, proxyNotificationRegion);
            try {
              if (!running) {
                return null;
              }
              proxyFactory.createAllProxies(member, proxyMonitoringRegion);

              managementCacheListener.markReady();
              notifListener.markReady();
            } catch (Exception e) {
              if (logger.isDebugEnabled()) {
                logger.debug(""Error During GII Proxy creation"", e);
              }

              throw new ManagementException(e);
            }
          }

        } catch (Exception e) {
          throw new ManagementException(e);
        }

        // Before completing task intimate all listening ProxyListener which might send
        // notifications.
        service.memberJoined((InternalDistributedMember) member);

        // Send manager info to the added member
        messenger.sendManagerInfo(member);

        return member;
      }
    }",True
"    public DistributedMember call() {
      synchronized (member) {
        String appender = MBeanJMXAdapter.getUniqueIDForMember(member);
        String monitoringRegionName = ManagementConstants.MONITORING_REGION + ""_"" + appender;
        String notificationRegionName = ManagementConstants.NOTIFICATION_REGION + ""_"" + appender;


        if (cache.getInternalRegion(monitoringRegionName) != null
            && cache.getInternalRegion(notificationRegionName) != null) {
          return member;
        }

        try {

          // GII wont start at all if its interrupted
          if (!Thread.currentThread().isInterrupted()) {

            // as the regions will be internal regions
            InternalRegionArguments internalRegionArguments = new InternalRegionArguments();
            internalRegionArguments.setIsUsedForMetaRegion(true);

            // Create anonymous stats holder for Management Regions
            HasCachePerfStats monitoringRegionStats =
                () -> new CachePerfStats(cache.getDistributedSystem(), ""managementRegionStats"");

            internalRegionArguments.setCachePerfStatsHolder(monitoringRegionStats);

            // Monitoring region for member is created
            AttributesFactory<String, Object> monitorAttributesFactory = new AttributesFactory<>();
            monitorAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
            monitorAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
            monitorAttributesFactory.setConcurrencyChecksEnabled(false);
            ManagementCacheListener managementCacheListener =
                new ManagementCacheListener(proxyFactory);
            monitorAttributesFactory.addCacheListener(managementCacheListener);

            RegionAttributes<String, Object> monitoringRegionAttrs =
                monitorAttributesFactory.create();

            // Notification region for member is created
            AttributesFactory<NotificationKey, Notification> notificationAttributesFactory =
                new AttributesFactory<>();
            notificationAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
            notificationAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
            notificationAttributesFactory.setConcurrencyChecksEnabled(false);

            // Fix for issue #49638, evict the internal region _notificationRegion
            notificationAttributesFactory
                .setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
                    ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));

            NotificationCacheListener notifListener = new NotificationCacheListener(proxyFactory);
            notificationAttributesFactory.addCacheListener(notifListener);

            RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
                notificationAttributesFactory.create();

            boolean proxyMonitoringRegionCreated;

            Region<String, Object> proxyMonitoringRegion;
            try {
              if (!running) {
                return null;
              }
              proxyMonitoringRegion =
                  cache.createInternalRegion(monitoringRegionName, monitoringRegionAttrs,
                      internalRegionArguments);
              proxyMonitoringRegionCreated = true;

            } catch (TimeoutException | RegionExistsException | IOException
                | ClassNotFoundException e) {
              if (logger.isDebugEnabled()) {
                logger.debug(""Error During Internal Region creation"", e);
              }
              throw new ManagementException(e);
            }

            boolean proxyNotificationRegionCreated = false;
            Region<NotificationKey, Notification> proxyNotificationRegion;
            try {
              if (!running) {
                return null;
              }
              proxyNotificationRegion =
                  cache.createInternalRegion(notificationRegionName, notifRegionAttrs,
                      internalRegionArguments);
              proxyNotificationRegionCreated = true;
            } catch (TimeoutException | RegionExistsException | IOException
                | ClassNotFoundException e) {
              if (logger.isDebugEnabled()) {
                logger.debug(""Error During Internal Region creation"", e);
              }
              throw new ManagementException(e);
            } finally {
              if (!proxyNotificationRegionCreated && proxyMonitoringRegionCreated) {
                // Destroy the proxy region if proxy notification region is not created
                proxyMonitoringRegion.localDestroyRegion();
              }
            }

            if (logger.isDebugEnabled()) {
              logger.debug(""Management Region created with Name : {}"",
                  proxyMonitoringRegion.getName());
              logger.debug(""Notification Region created with Name : {}"",
                  proxyNotificationRegion.getName());
            }

            // Only the exception case would have destroyed the proxy
            // regions. We can safely proceed here.
            repo.putEntryInMonitoringRegionMap(member, proxyMonitoringRegion);
            repo.putEntryInNotifRegionMap(member, proxyNotificationRegion);
            try {
              if (!running) {
                return null;
              }
              proxyFactory.createAllProxies(member, proxyMonitoringRegion);

              managementCacheListener.markReady();
              notifListener.markReady();
            } catch (Exception e) {
              if (logger.isDebugEnabled()) {
                logger.debug(""Error During GII Proxy creation"", e);
              }

              throw new ManagementException(e);
            }
          }

        } catch (Exception e) {
          throw new ManagementException(e);
        }

        // Before completing task intimate all listening ProxyListener which might send
        // notifications.
        service.memberJoined((InternalDistributedMember) member);

        // Send manager info to the added member
        messenger.sendManagerInfo(member);

        return member;
      }
    }",False
"  public JmxManagerAdvisee(InternalCache cache) {
    this.serialNumber = DistributionAdvisor.createSerialNumber();
    this.cache = cache;
  }",True
"  public JmxManagerAdvisee(InternalCacheForClientAccess cache) {
    this.serialNumber = DistributionAdvisor.createSerialNumber();
    this.cache = cache;
  }",False
"    public void execute(FunctionContext context) {
      try {
        Cache cache = CacheFactory.getAnyInstance();
        if (cache != null) {
          ManagementService ms = ManagementService.getExistingManagementService(cache);
          if (ms != null) {
            if (!ms.isManager()) { // see bug 45922
              ms.startManager();
            }
            context.getResultSender().lastResult(Boolean.TRUE);
          }
        }
        context.getResultSender().lastResult(Boolean.FALSE);
      } catch (AlreadyRunningException ignored) {
        context.getResultSender().lastResult(Boolean.TRUE);
      } catch (Exception e) {
        context.getResultSender().lastResult(""Exception in StartJmxManager ="" + e.getMessage());
      }
    }",True
"    public void execute(FunctionContext context) {
      try {
        InternalCache cache =
            ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
        if (cache != null) {
          ManagementService ms = ManagementService.getExistingManagementService(cache);
          if (ms != null) {
            if (!ms.isManager()) { // see bug 45922
              ms.startManager();
            }
            context.getResultSender().lastResult(Boolean.TRUE);
          }
        }
        context.getResultSender().lastResult(Boolean.FALSE);
      } catch (AlreadyRunningException ignored) {
        context.getResultSender().lastResult(Boolean.TRUE);
      } catch (Exception e) {
        context.getResultSender().lastResult(""Exception in StartJmxManager ="" + e.getMessage());
      }
    }",False
"  public void restarting(DistributedSystem ds, GemFireCache cache,
      InternalConfigurationPersistenceService sharedConfig) {
    this.cache = (InternalCache) cache;
  }",True
"  public void restarting(DistributedSystem ds, GemFireCache cache,
      InternalConfigurationPersistenceService sharedConfig) {
    this.cache = ((InternalCache) cache).getCacheForProcessingClientRequests();
  }",False
"  public JmxManagerLocator(InternalCache internalCache) {
    this.cache = internalCache;
  }",True
"  public JmxManagerLocator(InternalCache internalCache) {
    this.cache = internalCache.getCacheForProcessingClientRequests();
  }",False
"  private void startLocalManagement(Map<ObjectName, FederationComponent> federatedComponentMap) {

    synchronized (this) {
      if (repo.getLocalMonitoringRegion() != null) {
        return;
      } else {
        singleThreadFederationScheduler =
            LoggingExecutors.newSingleThreadScheduledExecutor(""Management Task"");

        if (logger.isDebugEnabled()) {
          logger.debug(""Creating  Management Region :"");
        }

        /*
         * Sharing the same Internal Argument for both notification region and monitoring region
         */
        InternalRegionArguments internalArgs = new InternalRegionArguments();
        internalArgs.setIsUsedForMetaRegion(true);

        // Create anonymous stats holder for Management Regions
        final HasCachePerfStats monitoringRegionStats = new HasCachePerfStats() {
          public CachePerfStats getCachePerfStats() {
            return new CachePerfStats(cache.getDistributedSystem(), ""managementRegionStats"");
          }
        };

        internalArgs.setCachePerfStatsHolder(monitoringRegionStats);

        AttributesFactory<String, Object> monitorRegionAttributeFactory =
            new AttributesFactory<String, Object>();
        monitorRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
        monitorRegionAttributeFactory.setDataPolicy(DataPolicy.REPLICATE);
        monitorRegionAttributeFactory.setConcurrencyChecksEnabled(false);
        MonitoringRegionCacheListener localListener = new MonitoringRegionCacheListener(service);
        monitorRegionAttributeFactory.addCacheListener(localListener);

        RegionAttributes<String, Object> monitoringRegionAttrs =
            monitorRegionAttributeFactory.create();

        AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
            new AttributesFactory<NotificationKey, Notification>();
        notificationRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
        notificationRegionAttributeFactory.setDataPolicy(DataPolicy.EMPTY);
        notificationRegionAttributeFactory.setConcurrencyChecksEnabled(false);

        RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
            notificationRegionAttributeFactory.create();

        String appender = MBeanJMXAdapter
            .getUniqueIDForMember(cache.getDistributedSystem().getDistributedMember());

        boolean monitoringRegionCreated = false;
        boolean notifRegionCreated = false;

        try {
          repo.setLocalMonitoringRegion(
              cache.createVMRegion(ManagementConstants.MONITORING_REGION + ""_"" + appender,
                  monitoringRegionAttrs, internalArgs));
          monitoringRegionCreated = true;

        } catch (TimeoutException e) {
          throw new ManagementException(e);
        } catch (RegionExistsException e) {
          throw new ManagementException(e);
        } catch (IOException e) {
          throw new ManagementException(e);
        } catch (ClassNotFoundException e) {
          throw new ManagementException(e);
        }

        try {
          repo.setLocalNotificationRegion(
              cache.createVMRegion(ManagementConstants.NOTIFICATION_REGION + ""_"" + appender,
                  notifRegionAttrs, internalArgs));
          notifRegionCreated = true;
        } catch (TimeoutException e) {
          throw new ManagementException(e);
        } catch (RegionExistsException e) {
          throw new ManagementException(e);
        } catch (IOException e) {
          throw new ManagementException(e);
        } catch (ClassNotFoundException e) {
          throw new ManagementException(e);
        } finally {
          if (!notifRegionCreated && monitoringRegionCreated) {
            repo.getLocalMonitoringRegion().localDestroyRegion();

          }
        }

        managementTask = new ManagementTask(federatedComponentMap);
        // call run to get us initialized immediately with a sync call
        managementTask.run();
        // All local resources are created for the ManagementTask
        // Now Management tasks can proceed.
        int updateRate = cache.getInternalDistributedSystem().getConfig().getJmxManagerUpdateRate();
        singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
            TimeUnit.MILLISECONDS);

        if (logger.isDebugEnabled()) {
          logger.debug(""Management Region created with Name : {}"",
              repo.getLocalMonitoringRegion().getName());
          logger.debug(""Notification Region created with Name : {}"",
              repo.getLocalNotificationRegion().getName());
        }
      }
    }
  }",True
"  private void startLocalManagement(Map<ObjectName, FederationComponent> federatedComponentMap) {

    synchronized (this) {
      if (repo.getLocalMonitoringRegion() != null) {
        return;
      } else {
        singleThreadFederationScheduler =
            LoggingExecutors.newSingleThreadScheduledExecutor(""Management Task"");

        if (logger.isDebugEnabled()) {
          logger.debug(""Creating  Management Region :"");
        }

        /*
         * Sharing the same Internal Argument for both notification region and monitoring region
         */
        InternalRegionArguments internalArgs = new InternalRegionArguments();
        internalArgs.setIsUsedForMetaRegion(true);

        // Create anonymous stats holder for Management Regions
        final HasCachePerfStats monitoringRegionStats = new HasCachePerfStats() {
          public CachePerfStats getCachePerfStats() {
            return new CachePerfStats(cache.getDistributedSystem(), ""managementRegionStats"");
          }
        };

        internalArgs.setCachePerfStatsHolder(monitoringRegionStats);

        AttributesFactory<String, Object> monitorRegionAttributeFactory =
            new AttributesFactory<String, Object>();
        monitorRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
        monitorRegionAttributeFactory.setDataPolicy(DataPolicy.REPLICATE);
        monitorRegionAttributeFactory.setConcurrencyChecksEnabled(false);
        MonitoringRegionCacheListener localListener = new MonitoringRegionCacheListener(service);
        monitorRegionAttributeFactory.addCacheListener(localListener);

        RegionAttributes<String, Object> monitoringRegionAttrs =
            monitorRegionAttributeFactory.create();

        AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
            new AttributesFactory<NotificationKey, Notification>();
        notificationRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
        notificationRegionAttributeFactory.setDataPolicy(DataPolicy.EMPTY);
        notificationRegionAttributeFactory.setConcurrencyChecksEnabled(false);

        RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
            notificationRegionAttributeFactory.create();

        String appender = MBeanJMXAdapter
            .getUniqueIDForMember(cache.getDistributedSystem().getDistributedMember());

        boolean monitoringRegionCreated = false;
        boolean notifRegionCreated = false;

        try {
          repo.setLocalMonitoringRegion(
              cache.createInternalRegion(ManagementConstants.MONITORING_REGION + ""_"" + appender,
                  monitoringRegionAttrs, internalArgs));
          monitoringRegionCreated = true;

        } catch (TimeoutException e) {
          throw new ManagementException(e);
        } catch (RegionExistsException e) {
          throw new ManagementException(e);
        } catch (IOException e) {
          throw new ManagementException(e);
        } catch (ClassNotFoundException e) {
          throw new ManagementException(e);
        }

        try {
          repo.setLocalNotificationRegion(
              cache.createInternalRegion(ManagementConstants.NOTIFICATION_REGION + ""_"" + appender,
                  notifRegionAttrs, internalArgs));
          notifRegionCreated = true;
        } catch (TimeoutException e) {
          throw new ManagementException(e);
        } catch (RegionExistsException e) {
          throw new ManagementException(e);
        } catch (IOException e) {
          throw new ManagementException(e);
        } catch (ClassNotFoundException e) {
          throw new ManagementException(e);
        } finally {
          if (!notifRegionCreated && monitoringRegionCreated) {
            repo.getLocalMonitoringRegion().localDestroyRegion();

          }
        }

        managementTask = new ManagementTask(federatedComponentMap);
        // call run to get us initialized immediately with a sync call
        managementTask.run();
        // All local resources are created for the ManagementTask
        // Now Management tasks can proceed.
        int updateRate = cache.getInternalDistributedSystem().getConfig().getJmxManagerUpdateRate();
        singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
            TimeUnit.MILLISECONDS);

        if (logger.isDebugEnabled()) {
          logger.debug(""Management Region created with Name : {}"",
              repo.getLocalMonitoringRegion().getName());
          logger.debug(""Notification Region created with Name : {}"",
              repo.getLocalNotificationRegion().getName());
        }
      }
    }
  }",False
"  public static InternalCacheForClientAccess getCache() {
    InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();
    if (cache != null) {
      return cache.getCacheForProcessingClientRequests();
    }
    return null;
  }",False
"  private void startHttpService(boolean isServer) {
    final SystemManagementService managementService = (SystemManagementService) ManagementService
        .getManagementService(CacheFactory.getAnyInstance());

    final ManagerMXBean managerBean = managementService.getManagerMXBean();

    if (this.config.getHttpServicePort() != 0) {
      if (logger.isDebugEnabled()) {
        logger.debug(""Attempting to start HTTP service on port ({}) at bind-address ({})..."",
            this.config.getHttpServicePort(), this.config.getHttpServiceBindAddress());
      }

      // Find the Management WAR file
      final String gemfireWar = agentUtil.findWarLocation(""geode-web"");
      if (gemfireWar == null) {
        if (logger.isDebugEnabled()) {
          logger.debug(
              ""Unable to find GemFire Management REST API WAR file; the Management REST Interface for GemFire will not be accessible."");
        }
      }

      // Find the Pulse WAR file
      final String pulseWar = agentUtil.findWarLocation(""geode-pulse"");

      if (pulseWar == null) {
        final String message =
            ""Unable to find Pulse web application WAR file; Pulse for GemFire will not be accessible"";
        setStatusMessage(managerBean, message);
        if (logger.isDebugEnabled()) {
          logger.debug(message);
        }
      } else {
        String pwFile = this.config.getJmxManagerPasswordFile();
        if (securityService.isIntegratedSecurity() || StringUtils.isNotBlank(pwFile)) {
          System.setProperty(""spring.profiles.active"", ""pulse.authentication.gemfire"");
        }
      }

      // Find developer REST WAR file
      final String gemfireAPIWar = agentUtil.findWarLocation(""geode-web-api"");
      if (gemfireAPIWar == null) {
        final String message =
            ""Unable to find GemFire Developer REST API WAR file; the Developer REST Interface for GemFire will not be accessible."";
        setStatusMessage(managerBean, message);
        if (logger.isDebugEnabled()) {
          logger.debug(message);
        }
      }

      try {
        if (agentUtil.isWebApplicationAvailable(gemfireWar, pulseWar, gemfireAPIWar)) {

          final String bindAddress = this.config.getHttpServiceBindAddress();
          final int port = this.config.getHttpServicePort();

          boolean isRestWebAppAdded = false;

          this.httpServer = JettyHelper.initJetty(bindAddress, port, SSLConfigurationFactory
              .getSSLConfigForComponent(config, SecurableCommunicationChannel.WEB));

          if (agentUtil.isWebApplicationAvailable(gemfireWar)) {
            this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/gemfire"", gemfireWar,
                securityService, null);
            this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/geode-mgmt"",
                gemfireWar, securityService, null);
          }

          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
            this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/pulse"", pulseWar,
                securityService, createSslProps());
          }

          if (isServer && this.config.getStartDevRestApi()) {
            if (agentUtil.isWebApplicationAvailable(gemfireAPIWar)) {
              this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/geode"",
                  gemfireAPIWar, securityService, null);
              this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/gemfire-api"",
                  gemfireAPIWar, securityService, null);
              isRestWebAppAdded = true;
            }
          } else {
            final String message =
                ""Developer REST API web application will not start when start-dev-rest-api is not set and node is not server"";
            setStatusMessage(managerBean, message);
            if (logger.isDebugEnabled()) {
              logger.debug(message);
            }
          }

          if (logger.isDebugEnabled()) {
            logger.debug(""Starting HTTP embedded server on port ({}) at bind-address ({})..."",
                ((ServerConnector) this.httpServer.getConnectors()[0]).getPort(), bindAddress);
          }

          System.setProperty(PULSE_EMBEDDED_PROP, ""true"");
          System.setProperty(PULSE_HOST_PROP, """" + config.getJmxManagerBindAddress());
          System.setProperty(PULSE_PORT_PROP, """" + config.getJmxManagerPort());

          final SocketCreator jmxSocketCreator =
              SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.JMX);
          final SocketCreator locatorSocketCreator = SocketCreatorFactory
              .getSocketCreatorForComponent(SecurableCommunicationChannel.LOCATOR);
          System.setProperty(PULSE_USESSL_MANAGER, jmxSocketCreator.useSSL() + """");
          System.setProperty(PULSE_USESSL_LOCATOR, locatorSocketCreator.useSSL() + """");

          this.httpServer = JettyHelper.startJetty(this.httpServer);

          // now, that Tomcat has been started, we can set the URL used by web
          // clients to connect to Pulse
          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
            managerBean.setPulseURL(""http://"".concat(getHost(bindAddress)).concat("":"")
                .concat(String.valueOf(port)).concat(""/pulse/""));
          }

          // set cache property for developer REST service running
          if (isRestWebAppAdded) {
            InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();
            cache.setRESTServiceRunning(true);

            // create region to hold query information (queryId, queryString).
            // Added for the developer REST APIs
            RestAgent.createParameterizedQueryRegion();
          }

          // set true for HTTP service running
          setHttpServiceRunning(true);
        }
      } catch (Exception e) {
        stopHttpService();// Jetty needs to be stopped even if it has failed to
        // start. Some of the threads are left behind even if
        // server.start() fails due to an exception
        setStatusMessage(managerBean, ""HTTP service failed to start with ""
            + e.getClass().getSimpleName() + "" '"" + e.getMessage() + ""'"");
        throw new ManagementException(""HTTP service failed to start"", e);
      }
    } else {
      setStatusMessage(managerBean,
          ""Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)"");
    }
  }",True
"  private void startHttpService(boolean isServer) {
    final SystemManagementService managementService = (SystemManagementService) ManagementService
        .getManagementService(getCache());

    final ManagerMXBean managerBean = managementService.getManagerMXBean();

    if (this.config.getHttpServicePort() != 0) {
      if (logger.isDebugEnabled()) {
        logger.debug(""Attempting to start HTTP service on port ({}) at bind-address ({})..."",
            this.config.getHttpServicePort(), this.config.getHttpServiceBindAddress());
      }

      // Find the Management WAR file
      final String gemfireWar = agentUtil.findWarLocation(""geode-web"");
      if (gemfireWar == null) {
        if (logger.isDebugEnabled()) {
          logger.debug(
              ""Unable to find GemFire Management REST API WAR file; the Management REST Interface for GemFire will not be accessible."");
        }
      }

      // Find the Pulse WAR file
      final String pulseWar = agentUtil.findWarLocation(""geode-pulse"");

      if (pulseWar == null) {
        final String message =
            ""Unable to find Pulse web application WAR file; Pulse for GemFire will not be accessible"";
        setStatusMessage(managerBean, message);
        if (logger.isDebugEnabled()) {
          logger.debug(message);
        }
      } else {
        String pwFile = this.config.getJmxManagerPasswordFile();
        if (securityService.isIntegratedSecurity() || StringUtils.isNotBlank(pwFile)) {
          System.setProperty(""spring.profiles.active"", ""pulse.authentication.gemfire"");
        }
      }

      // Find developer REST WAR file
      final String gemfireAPIWar = agentUtil.findWarLocation(""geode-web-api"");
      if (gemfireAPIWar == null) {
        final String message =
            ""Unable to find GemFire Developer REST API WAR file; the Developer REST Interface for GemFire will not be accessible."";
        setStatusMessage(managerBean, message);
        if (logger.isDebugEnabled()) {
          logger.debug(message);
        }
      }

      try {
        if (agentUtil.isWebApplicationAvailable(gemfireWar, pulseWar, gemfireAPIWar)) {

          final String bindAddress = this.config.getHttpServiceBindAddress();
          final int port = this.config.getHttpServicePort();

          boolean isRestWebAppAdded = false;

          this.httpServer = JettyHelper.initJetty(bindAddress, port, SSLConfigurationFactory
              .getSSLConfigForComponent(config, SecurableCommunicationChannel.WEB));

          if (agentUtil.isWebApplicationAvailable(gemfireWar)) {
            this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/gemfire"", gemfireWar,
                securityService, null);
            this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/geode-mgmt"",
                gemfireWar, securityService, null);
          }

          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
            this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/pulse"", pulseWar,
                securityService, createSslProps());
          }

          if (isServer && this.config.getStartDevRestApi()) {
            if (agentUtil.isWebApplicationAvailable(gemfireAPIWar)) {
              this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/geode"",
                  gemfireAPIWar, securityService, null);
              this.httpServer = JettyHelper.addWebApplication(this.httpServer, ""/gemfire-api"",
                  gemfireAPIWar, securityService, null);
              isRestWebAppAdded = true;
            }
          } else {
            final String message =
                ""Developer REST API web application will not start when start-dev-rest-api is not set and node is not server"";
            setStatusMessage(managerBean, message);
            if (logger.isDebugEnabled()) {
              logger.debug(message);
            }
          }

          if (logger.isDebugEnabled()) {
            logger.debug(""Starting HTTP embedded server on port ({}) at bind-address ({})..."",
                ((ServerConnector) this.httpServer.getConnectors()[0]).getPort(), bindAddress);
          }

          System.setProperty(PULSE_EMBEDDED_PROP, ""true"");
          System.setProperty(PULSE_HOST_PROP, """" + config.getJmxManagerBindAddress());
          System.setProperty(PULSE_PORT_PROP, """" + config.getJmxManagerPort());

          final SocketCreator jmxSocketCreator =
              SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.JMX);
          final SocketCreator locatorSocketCreator = SocketCreatorFactory
              .getSocketCreatorForComponent(SecurableCommunicationChannel.LOCATOR);
          System.setProperty(PULSE_USESSL_MANAGER, jmxSocketCreator.useSSL() + """");
          System.setProperty(PULSE_USESSL_LOCATOR, locatorSocketCreator.useSSL() + """");

          this.httpServer = JettyHelper.startJetty(this.httpServer);

          // now, that Tomcat has been started, we can set the URL used by web
          // clients to connect to Pulse
          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
            managerBean.setPulseURL(""http://"".concat(getHost(bindAddress)).concat("":"")
                .concat(String.valueOf(port)).concat(""/pulse/""));
          }

          // set cache property for developer REST service running
          if (isRestWebAppAdded) {
            InternalCache cache = getCache();
            cache.setRESTServiceRunning(true);

            // create region to hold query information (queryId, queryString).
            // Added for the developer REST APIs
            RestAgent.createParameterizedQueryRegion();
          }

          // set true for HTTP service running
          setHttpServiceRunning(true);
        }
      } catch (Exception e) {
        stopHttpService();// Jetty needs to be stopped even if it has failed to
        // start. Some of the threads are left behind even if
        // server.start() fails due to an exception
        setStatusMessage(managerBean, ""HTTP service failed to start with ""
            + e.getClass().getSimpleName() + "" '"" + e.getMessage() + ""'"");
        throw new ManagementException(""HTTP service failed to start"", e);
      }
    } else {
      setStatusMessage(managerBean,
          ""Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)"");
    }
  }",False
"  public void execute(FunctionContext fc) {

    boolean executedSuccessfully = false;

    InternalCache cache = GemFireCacheImpl.getInstance();

    Object[] functionArguments = (Object[]) fc.getArguments();

    ObjectName objectName = (ObjectName) functionArguments[0];

    String methodName = (String) functionArguments[1];

    String[] signature = (String[]) functionArguments[2];

    Object[] args = (Object[]) functionArguments[3];
    String memberName = (String) functionArguments[4];

    Object returnObj = null;

    try {

      final int nargs = (args == null) ? 0 : args.length;

      if (methodName.startsWith(""set"") && methodName.length() > 3 && nargs == 1) {

        Attribute attr = new Attribute(methodName.substring(3), args[0]);
        mbeanServer.setAttribute(objectName, attr);
        fc.getResultSender().lastResult((Serializable) null);

      } else if (methodName.equals(""addNotificationListener"")) {
        notificationHub.addHubNotificationListener(memberName, objectName);
        fc.getResultSender().lastResult((Serializable) ManagementConstants.UNDEFINED);

      } else if (methodName.equals(""removeNotificationListener"")) {
        notificationHub.removeHubNotificationListener(memberName, objectName);
        fc.getResultSender().lastResult((Serializable) ManagementConstants.UNDEFINED);

      } else if (methodName.equals(""getNotificationInfo"")) {
        fc.getResultSender().lastResult(mbeanServer.getMBeanInfo(objectName));

      } else {
        returnObj = mbeanServer.invoke(objectName, methodName, args, signature);
        fc.getResultSender().lastResult((Serializable) returnObj);
      }

      executedSuccessfully = true;

    } catch (InstanceNotFoundException e) {
      if (cache != null && !cache.isClosed()) {
        sendException(e, fc);
      }
    } catch (Exception e) {
      sendException(e, fc);
    } finally {
      if (!executedSuccessfully) {
        if (cache == null || cache.isClosed()) {
          Exception e =
              new Exception(""Member Is Shutting down"");
          sendException(e, fc);
          return; // member is closing or invalid member
        }
      }
    }
  }",True
"  public void execute(FunctionContext fc) {

    boolean executedSuccessfully = false;

    InternalCache cache = ((InternalCache) fc.getCache()).getCacheForProcessingClientRequests();

    Object[] functionArguments = (Object[]) fc.getArguments();

    ObjectName objectName = (ObjectName) functionArguments[0];

    String methodName = (String) functionArguments[1];

    String[] signature = (String[]) functionArguments[2];

    Object[] args = (Object[]) functionArguments[3];
    String memberName = (String) functionArguments[4];

    Object returnObj = null;

    try {

      final int nargs = (args == null) ? 0 : args.length;

      if (methodName.startsWith(""set"") && methodName.length() > 3 && nargs == 1) {

        Attribute attr = new Attribute(methodName.substring(3), args[0]);
        mbeanServer.setAttribute(objectName, attr);
        fc.getResultSender().lastResult((Serializable) null);

      } else if (methodName.equals(""addNotificationListener"")) {
        notificationHub.addHubNotificationListener(memberName, objectName);
        fc.getResultSender().lastResult((Serializable) ManagementConstants.UNDEFINED);

      } else if (methodName.equals(""removeNotificationListener"")) {
        notificationHub.removeHubNotificationListener(memberName, objectName);
        fc.getResultSender().lastResult((Serializable) ManagementConstants.UNDEFINED);

      } else if (methodName.equals(""getNotificationInfo"")) {
        fc.getResultSender().lastResult(mbeanServer.getMBeanInfo(objectName));

      } else {
        returnObj = mbeanServer.invoke(objectName, methodName, args, signature);
        fc.getResultSender().lastResult((Serializable) returnObj);
      }

      executedSuccessfully = true;

    } catch (InstanceNotFoundException e) {
      if (cache != null && !cache.isClosed()) {
        sendException(e, fc);
      }
    } catch (Exception e) {
      sendException(e, fc);
    } finally {
      if (!executedSuccessfully) {
        if (cache == null || cache.isClosed()) {
          Exception e =
              new Exception(""Member Is Shutting down"");
          sendException(e, fc);
          return; // member is closing or invalid member
        }
      }
    }
  }",False
"  public Manager(ManagementResourceRepo repo, InternalDistributedSystem system,
      InternalCache cache) {
    this.repo = repo;
    this.cache = cache;
    this.system = system;
  }",True
"  public Manager(ManagementResourceRepo repo, InternalDistributedSystem system,
      InternalCache cache) {
    this.repo = repo;
    this.cache = cache.getCacheForProcessingClientRequests();
    this.system = system;
  }",False
"  public static BaseManagementService newSystemManagementService(InternalCache cache) {
    return new SystemManagementService(cache).init();
  }",True
"  public static BaseManagementService newSystemManagementService(
      InternalCacheForClientAccess cache) {
    return new SystemManagementService(cache).init();
  }",False
"  protected SystemManagementService(InternalCache cache) {
    this.cache = cache;
    this.system = (InternalDistributedSystem) cache.getDistributedSystem();
    // This is a safe check to ensure Management service does not start for a
    // system which is disconnected.
    // Most likely scenario when this will happen is when a cache is closed and we are at this
    // point.
    if (!system.isConnected()) {
      throw new DistributedSystemDisconnectedException(
          ""This connection to a distributed system has been disconnected."");
    }
    this.jmxAdapter = new MBeanJMXAdapter();
    this.repo = new ManagementResourceRepo();


    this.notificationHub = new NotificationHub(repo);
    if (system.getConfig().getJmxManager()) {
      this.agent = new ManagementAgent(system.getConfig(), cache.getSecurityService());
    } else {
      this.agent = null;
    }
    ManagementFunction function = new ManagementFunction(notificationHub);
    FunctionService.registerFunction(function);
    this.proxyListeners = new CopyOnWriteArrayList<>();
  }",True
"  protected SystemManagementService(InternalCacheForClientAccess cache) {
    this.cache = cache;
    this.system = (InternalDistributedSystem) cache.getDistributedSystem();
    // This is a safe check to ensure Management service does not start for a
    // system which is disconnected.
    // Most likely scenario when this will happen is when a cache is closed and we are at this
    // point.
    if (!system.isConnected()) {
      throw new DistributedSystemDisconnectedException(
          ""This connection to a distributed system has been disconnected."");
    }
    this.jmxAdapter = new MBeanJMXAdapter();
    this.repo = new ManagementResourceRepo();


    this.notificationHub = new NotificationHub(repo);
    if (system.getConfig().getJmxManager()) {
      this.agent = new ManagementAgent(system.getConfig(), cache.getSecurityService());
    } else {
      this.agent = null;
    }
    ManagementFunction function = new ManagementFunction(notificationHub);
    FunctionService.registerFunction(function);
    this.proxyListeners = new CopyOnWriteArrayList<>();
  }",False
"
  public static BaseManagementService newSystemManagementService(
      InternalCacheForClientAccess cache) {",False
"  }

  protected SystemManagementService(InternalCacheForClientAccess cache) {
    this.cache = cache;
    this.system = (InternalDistributedSystem) cache.getDistributedSystem();
    // This is a safe check to ensure Management service does not start for a
    // system which is disconnected.
    // Most likely scenario when this will happen is when a cache is closed and we are at this
    // point.
    if (!system.isConnected()) {
      throw new DistributedSystemDisconnectedException(
          ""This connection to a distributed system has been disconnected."");
    }
    this.jmxAdapter = new MBeanJMXAdapter();
    this.repo = new ManagementResourceRepo();


    this.notificationHub = new NotificationHub(repo);
    if (system.getConfig().getJmxManager()) {
      this.agent = new ManagementAgent(system.getConfig(), cache.getSecurityService());
    } else {
      this.agent = null;
    }
    ManagementFunction function = new ManagementFunction(notificationHub);
    FunctionService.registerFunction(function);",False
"  public static DistributedMember getDistributedMemberByNameOrId(String memberNameOrId) {
    DistributedMember memberFound = null;

    if (memberNameOrId != null) {
      InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();
      Set<DistributedMember> memberSet = CliUtil.getAllMembers(cache);
      for (DistributedMember member : memberSet) {
        if (memberNameOrId.equals(member.getId()) || memberNameOrId.equals(member.getName())) {
          memberFound = member;
          break;
        }
      }
    }
    return memberFound;
  }",True
"  public static DistributedMember getDistributedMemberByNameOrId(String memberNameOrId) {
    DistributedMember memberFound = null;

    if (memberNameOrId != null) {
      InternalCache cache = ManagementAgent.getCache();
      Set<DistributedMember> memberSet = CliUtil.getAllMembers(cache);
      for (DistributedMember member : memberSet) {
        if (memberNameOrId.equals(member.getId()) || memberNameOrId.equals(member.getName())) {
          memberFound = member;
          break;
        }
      }
    }
    return memberFound;
  }",False
"  public Version getClientVersion(ClientConnInfo connInfo) {
    InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();

    if (cache.getCacheServers().size() == 0) {
      return null;
    }

    CacheServerImpl server = (CacheServerImpl) cache.getCacheServers().iterator().next();

    if (server == null) {
      return null;
    }

    AcceptorImpl acceptorImpl = server.getAcceptor();
    if (acceptorImpl == null) {
      return null;
    }

    ServerConnection[] serverConnections = acceptorImpl.getAllServerConnectionList();

    boolean flag = false;
    if (connInfo.toString().contains(""primary=true"")) {
      flag = true;
    }

    for (ServerConnection conn : serverConnections) {
      ClientProxyMembershipID cliIdFrmProxy = conn.getProxyID();
      ClientConnInfo cci =
          new ClientConnInfo(conn.getProxyID(), conn.getSocketHost(), conn.getSocketPort(), flag);
      if (connInfo.toString().equals(cci.toString())) {
        return cliIdFrmProxy.getClientVersion();
      }
    }

    // check form ccp
    ClientProxyMembershipID proxyId = connInfo.getClientId();
    CacheClientProxy proxy = CacheClientNotifier.getInstance().getClientProxy(proxyId);
    if (proxy != null) {
      return proxy.getVersion();
    } else {
      return null;
    }
  }",True
"    if (cache.getCacheServers().size() == 0) {
      return null;
    }

    CacheServerImpl server = (CacheServerImpl) cache.getCacheServers().iterator().next();

    if (server == null) {
      return null;
    }

    AcceptorImpl acceptorImpl = server.getAcceptor();
    if (acceptorImpl == null) {
      return null;
    }

    ServerConnection[] serverConnections = acceptorImpl.getAllServerConnectionList();

    boolean flag = false;
    if (connInfo.toString().contains(""primary=true"")) {
      flag = true;
    }

    for (ServerConnection conn : serverConnections) {
      ClientProxyMembershipID cliIdFrmProxy = conn.getProxyID();
      ClientConnInfo cci =
          new ClientConnInfo(conn.getProxyID(), conn.getSocketHost(), conn.getSocketPort(), flag);
      if (connInfo.toString().equals(cci.toString())) {
        return cliIdFrmProxy.getClientVersion();
      }
    }

    // check form ccp
    ClientProxyMembershipID proxyId = connInfo.getClientId();
    CacheClientProxy proxy = CacheClientNotifier.getInstance().getClientProxy(proxyId);
    if (proxy != null) {
      return proxy.getVersion();
    } else {
      return null;
    }
  }

  public ClientHealthStatus showClientStats(String clientId) throws Exception {
    try {",False
"    private InternalCache getCache() {
      return (InternalCache) CacheFactory.getAnyInstance();
    }",True
"      return this.id;
    }
  }",False
"  public static Object queryData(final String query, final String members, final int limit,
      final boolean zipResult, final int queryResultSetLimit, final int queryCollectionsDepth)
      throws Exception {

    if (query == null || query.isEmpty()) {
      return new JsonisedErrorMessage(""Query is either empty or Null"")
          .toString();
    }

    Set<DistributedMember> inputMembers = null;
    if (StringUtils.isNotBlank(members)) {
      inputMembers = new HashSet<>();
      StringTokenizer st = new StringTokenizer(members, "","");
      while (st.hasMoreTokens()) {
        String member = st.nextToken();
        DistributedMember distributedMember = BeanUtilFuncs.getDistributedMemberByNameOrId(member);
        inputMembers.add(distributedMember);
        if (distributedMember == null) {
          return new JsonisedErrorMessage(
              String.format(""Query is invalid due to invalid member : %s"", member)).toString();
        }
      }
    }

    InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();
    try {

      SystemManagementService service =
          (SystemManagementService) ManagementService.getExistingManagementService(cache);
      Set<String> regionsInQuery = compileQuery(cache, query);

      // Validate region existence
      if (regionsInQuery.size() > 0) {
        for (String regionPath : regionsInQuery) {
          DistributedRegionMXBean regionMBean = service.getDistributedRegionMXBean(regionPath);
          if (regionMBean == null) {
            return new JsonisedErrorMessage(
                String.format(""Cannot find regions %s in any of the members"", regionPath))
                    .toString();
          } else {
            Set<DistributedMember> associatedMembers =
                CliUtil.getRegionAssociatedMembers(regionPath, cache, true);

            if (inputMembers != null && inputMembers.size() > 0) {
              if (!associatedMembers.containsAll(inputMembers)) {
                return new JsonisedErrorMessage(
                    String.format(""Cannot find regions %s in specified members"", regionPath))
                        .toString();
              }
            }
          }
        }
      } else {
        return new JsonisedErrorMessage(String.format(""Query is invalid due to error : %s"",
            ""Region mentioned in query probably missing /"")).toString();
      }

      // Validate
      if (regionsInQuery.size() > 1 && inputMembers == null) {
        for (String regionPath : regionsInQuery) {
          DistributedRegionMXBean regionMBean = service.getDistributedRegionMXBean(regionPath);

          if (regionMBean.getRegionType().equals(DataPolicy.PARTITION.toString())
              || regionMBean.getRegionType().equals(DataPolicy.PERSISTENT_PARTITION.toString())) {
            return new JsonisedErrorMessage(
                ""Join operation can only be executed on targeted members, please give member input"")
                    .toString();
          }
        }
      }

      String randomRegion = regionsInQuery.iterator().next();

      // get the first available member
      Set<DistributedMember> associatedMembers =
          CliUtil.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);

      if (associatedMembers != null && associatedMembers.size() > 0) {
        Object[] functionArgs = new Object[6];
        if (inputMembers != null && inputMembers.size() > 0) {// on input
          // members

          functionArgs[DISPLAY_MEMBERWISE] = true;
          functionArgs[QUERY] = query;
          functionArgs[REGION] = randomRegion;
          functionArgs[LIMIT] = limit;
          functionArgs[QUERY_RESULTSET_LIMIT] = queryResultSetLimit;
          functionArgs[QUERY_COLLECTIONS_DEPTH] = queryCollectionsDepth;
          return callFunction(functionArgs, inputMembers, zipResult);
        } else { // Query on any random member
          functionArgs[DISPLAY_MEMBERWISE] = false;
          functionArgs[QUERY] = query;
          functionArgs[REGION] = randomRegion;
          functionArgs[LIMIT] = limit;
          functionArgs[QUERY_RESULTSET_LIMIT] = queryResultSetLimit;
          functionArgs[QUERY_COLLECTIONS_DEPTH] = queryCollectionsDepth;
          return callFunction(functionArgs, associatedMembers, zipResult);
        }

      } else {
        return new JsonisedErrorMessage(String
            .format(""Cannot find regions %s in any of the members"", regionsInQuery.toString()))
                .toString();
      }

    } catch (QueryInvalidException qe) {
      return new JsonisedErrorMessage(
          String.format(""Query is invalid due to error : %s"", qe.getMessage()))
              .toString();
    }
  }",True
"  public static Object queryData(final String query, final String members, final int limit,
      final boolean zipResult, final int queryResultSetLimit, final int queryCollectionsDepth)
      throws Exception {

    if (query == null || query.isEmpty()) {
      return new JsonisedErrorMessage(""Query is either empty or Null"")
          .toString();
    }

    Set<DistributedMember> inputMembers = null;
    if (StringUtils.isNotBlank(members)) {
      inputMembers = new HashSet<>();
      StringTokenizer st = new StringTokenizer(members, "","");
      while (st.hasMoreTokens()) {
        String member = st.nextToken();
        DistributedMember distributedMember = BeanUtilFuncs.getDistributedMemberByNameOrId(member);
        inputMembers.add(distributedMember);
        if (distributedMember == null) {
          return new JsonisedErrorMessage(
              String.format(""Query is invalid due to invalid member : %s"", member)).toString();
        }
      }
    }

    InternalCache cache = ManagementAgent.getCache();
    try {

      SystemManagementService service =
          (SystemManagementService) ManagementService.getExistingManagementService(cache);
      Set<String> regionsInQuery = compileQuery(cache, query);

      // Validate region existence
      if (regionsInQuery.size() > 0) {
        for (String regionPath : regionsInQuery) {
          DistributedRegionMXBean regionMBean = service.getDistributedRegionMXBean(regionPath);
          if (regionMBean == null) {
            return new JsonisedErrorMessage(
                String.format(""Cannot find regions %s in any of the members"", regionPath))
                    .toString();
          } else {
            Set<DistributedMember> associatedMembers =
                CliUtil.getRegionAssociatedMembers(regionPath, cache, true);

            if (inputMembers != null && inputMembers.size() > 0) {
              if (!associatedMembers.containsAll(inputMembers)) {
                return new JsonisedErrorMessage(
                    String.format(""Cannot find regions %s in specified members"", regionPath))
                        .toString();
              }
            }
          }
        }
      } else {
        return new JsonisedErrorMessage(String.format(""Query is invalid due to error : %s"",
            ""Region mentioned in query probably missing /"")).toString();
      }

      // Validate
      if (regionsInQuery.size() > 1 && inputMembers == null) {
        for (String regionPath : regionsInQuery) {
          DistributedRegionMXBean regionMBean = service.getDistributedRegionMXBean(regionPath);

          if (regionMBean.getRegionType().equals(DataPolicy.PARTITION.toString())
              || regionMBean.getRegionType().equals(DataPolicy.PERSISTENT_PARTITION.toString())) {
            return new JsonisedErrorMessage(
                ""Join operation can only be executed on targeted members, please give member input"")
                    .toString();
          }
        }
      }

      String randomRegion = regionsInQuery.iterator().next();

      // get the first available member
      Set<DistributedMember> associatedMembers =
          CliUtil.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);

      if (associatedMembers != null && associatedMembers.size() > 0) {
        Object[] functionArgs = new Object[6];
        if (inputMembers != null && inputMembers.size() > 0) {// on input
          // members

          functionArgs[DISPLAY_MEMBERWISE] = true;
          functionArgs[QUERY] = query;
          functionArgs[REGION] = randomRegion;
          functionArgs[LIMIT] = limit;
          functionArgs[QUERY_RESULTSET_LIMIT] = queryResultSetLimit;
          functionArgs[QUERY_COLLECTIONS_DEPTH] = queryCollectionsDepth;
          return callFunction(functionArgs, inputMembers, zipResult);
        } else { // Query on any random member
          functionArgs[DISPLAY_MEMBERWISE] = false;
          functionArgs[QUERY] = query;
          functionArgs[REGION] = randomRegion;
          functionArgs[LIMIT] = limit;
          functionArgs[QUERY_RESULTSET_LIMIT] = queryResultSetLimit;
          functionArgs[QUERY_COLLECTIONS_DEPTH] = queryCollectionsDepth;
          return callFunction(functionArgs, associatedMembers, zipResult);
        }

      } else {
        return new JsonisedErrorMessage(String
            .format(""Cannot find regions %s in any of the members"", regionsInQuery.toString()))
                .toString();
      }

    } catch (QueryInvalidException qe) {
      return new JsonisedErrorMessage(
          String.format(""Query is invalid due to error : %s"", qe.getMessage()))
              .toString();
    }
  }",False
"  private InternalCache getCache() {
    return (InternalCache) CacheFactory.getAnyInstance();
  }",True
"
  private static class JsonisedErrorMessage {
",False
"  private QueryDataFunctionResult selectWithType(final FunctionContext context, String queryString,
      final boolean showMember, final String regionName, final int limit,
      final int queryResultSetLimit, final int queryCollectionsDepth) throws Exception {
    InternalCache cache = getCache();
    Function localQueryFunc = new LocalQueryFunction(""LocalQueryFunction"", regionName, showMember)
        .setOptimizeForWrite(true);
    queryString = applyLimitClause(queryString, limit, queryResultSetLimit);

    try {
      TypedJson result = new TypedJson(queryCollectionsDepth);

      Region region = cache.getRegion(regionName);

      if (region == null) {
        throw new Exception(String.format(""Cannot find region %s in member %s"", regionName,
            cache.getDistributedSystem().getDistributedMember().getId()));
      }

      Object results = null;

      boolean noDataFound = true;

      if (region.getAttributes().getDataPolicy() == DataPolicy.NORMAL) {
        QueryService queryService = cache.getQueryService();

        Query query = queryService.newQuery(queryString);
        results = query.execute();

      } else {
        ResultCollector rcollector;

        PartitionedRegion parRegion =
            PartitionedRegionHelper.getPartitionedRegion(regionName, cache);
        if (parRegion != null && showMember) {
          if (parRegion.isDataStore()) {

            Set<BucketRegion> localPrimaryBucketRegions =
                parRegion.getDataStore().getAllLocalPrimaryBucketRegions();
            Set<Integer> localPrimaryBucketSet = new HashSet<>();
            for (BucketRegion bRegion : localPrimaryBucketRegions) {
              localPrimaryBucketSet.add(bRegion.getId());
            }
            LocalDataSet lds = new LocalDataSet(parRegion, localPrimaryBucketSet);
            DefaultQuery query = (DefaultQuery) cache.getQueryService().newQuery(queryString);
            results = lds.executeQuery(query, null, localPrimaryBucketSet);
          }
        } else {
          rcollector = FunctionService.onRegion(cache.getRegion(regionName))
              .setArguments(queryString).execute(localQueryFunc);
          results = rcollector.getResult();
        }
      }

      if (results != null && results instanceof SelectResults) {

        SelectResults selectResults = (SelectResults) results;
        for (Object object : selectResults) {
          result.add(RESULT_KEY, object);
          noDataFound = false;
        }
      } else if (results != null && results instanceof ArrayList) {
        ArrayList listResults = (ArrayList) results;
        ArrayList actualResult = (ArrayList) listResults.get(0);
        for (Object object : actualResult) {
          result.add(RESULT_KEY, object);
          noDataFound = false;
        }
      }

      if (!noDataFound && showMember) {
        result.add(MEMBER_KEY, cache.getDistributedSystem().getDistributedMember().getId());
      }

      if (noDataFound) {
        return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS,
            BeanUtilFuncs.compress(new JsonisedErrorMessage(NO_DATA_FOUND).toString()));
      }
      return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS,
          BeanUtilFuncs.compress(result.toString()));
    } catch (Exception e) {
      logger.warn(e.getMessage(), e);
      throw e;
    }
  }",True
"  private QueryDataFunctionResult selectWithType(final FunctionContext context, String queryString,
      final boolean showMember, final String regionName, final int limit,
      final int queryResultSetLimit, final int queryCollectionsDepth) throws Exception {
    InternalCache cache =
        ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
    Function localQueryFunc = new LocalQueryFunction(""LocalQueryFunction"", regionName, showMember)
        .setOptimizeForWrite(true);
    queryString = applyLimitClause(queryString, limit, queryResultSetLimit);

    try {
      TypedJson result = new TypedJson(queryCollectionsDepth);

      Region region = cache.getRegion(regionName);

      if (region == null) {
        throw new Exception(String.format(""Cannot find region %s in member %s"", regionName,
            cache.getDistributedSystem().getDistributedMember().getId()));
      }

      Object results = null;

      boolean noDataFound = true;

      if (region.getAttributes().getDataPolicy() == DataPolicy.NORMAL) {
        QueryService queryService = cache.getQueryService();

        Query query = queryService.newQuery(queryString);
        results = query.execute();

      } else {
        ResultCollector rcollector;

        PartitionedRegion parRegion =
            PartitionedRegionHelper.getPartitionedRegion(regionName, cache);
        if (parRegion != null && showMember) {
          if (parRegion.isDataStore()) {

            Set<BucketRegion> localPrimaryBucketRegions =
                parRegion.getDataStore().getAllLocalPrimaryBucketRegions();
            Set<Integer> localPrimaryBucketSet = new HashSet<>();
            for (BucketRegion bRegion : localPrimaryBucketRegions) {
              localPrimaryBucketSet.add(bRegion.getId());
            }
            LocalDataSet lds = new LocalDataSet(parRegion, localPrimaryBucketSet);
            DefaultQuery query = (DefaultQuery) cache.getQueryService().newQuery(queryString);
            results = lds.executeQuery(query, null, localPrimaryBucketSet);
          }
        } else {
          rcollector = FunctionService.onRegion(cache.getRegion(regionName))
              .setArguments(queryString).execute(localQueryFunc);
          results = rcollector.getResult();
        }
      }

      if (results != null && results instanceof SelectResults) {

        SelectResults selectResults = (SelectResults) results;
        for (Object object : selectResults) {
          result.add(RESULT_KEY, object);
          noDataFound = false;
        }
      } else if (results != null && results instanceof ArrayList) {
        ArrayList listResults = (ArrayList) results;
        ArrayList actualResult = (ArrayList) listResults.get(0);
        for (Object object : actualResult) {
          result.add(RESULT_KEY, object);
          noDataFound = false;
        }
      }

      if (!noDataFound && showMember) {
        result.add(MEMBER_KEY, cache.getDistributedSystem().getDistributedMember().getId());
      }

      if (noDataFound) {
        return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS,
            BeanUtilFuncs.compress(new JsonisedErrorMessage(NO_DATA_FOUND).toString()));
      }
      return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS,
          BeanUtilFuncs.compress(result.toString()));
    } catch (Exception e) {
      logger.warn(e.getMessage(), e);
      throw e;
    }
  }",False
"    public void execute(final FunctionContext context) {
      InternalCache cache = getCache();
      QueryService queryService = cache.getQueryService();
      String qstr = (String) context.getArguments();
      Region r = cache.getRegion(regionName);
      try {
        Query query = queryService.newQuery(qstr);
        SelectResults sr;
        if (r.getAttributes().getPartitionAttributes() != null && showMembers) {
          sr = (SelectResults) query.execute((RegionFunctionContext) context);
          context.getResultSender().lastResult(sr.asList());
        } else {
          sr = (SelectResults) query.execute();
          context.getResultSender().lastResult(sr.asList());
        }

      } catch (Exception e) {
        throw new FunctionException(e);
      }
    }",True
"    public void execute(final FunctionContext context) {
      InternalCache cache =
          ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
      QueryService queryService = cache.getQueryService();
      String qstr = (String) context.getArguments();
      Region r = cache.getRegion(regionName);
      try {
        Query query = queryService.newQuery(qstr);
        SelectResults sr;
        if (r.getAttributes().getPartitionAttributes() != null && showMembers) {
          sr = (SelectResults) query.execute((RegionFunctionContext) context);
          context.getResultSender().lastResult(sr.asList());
        } else {
          sr = (SelectResults) query.execute();
          context.getResultSender().lastResult(sr.asList());
        }

      } catch (Exception e) {
        throw new FunctionException(e);
      }
    }",False
"  public void execute(FunctionContext functionContext) {
    try {
      InternalCache cache = (InternalCache) functionContext.getCache();
      DataCommandRequest request = (DataCommandRequest) functionContext.getArguments();
      if (logger.isDebugEnabled()) {
        logger.debug(""Executing function : \n{}\n on member {}"", request,
            System.getProperty(""memberName""));
      }
      DataCommandResult result = null;
      if (request.isGet()) {
        result = get(request, cache);
      } else if (request.isLocateEntry()) {
        result = locateEntry(request, cache);
      } else if (request.isPut()) {
        result = put(request, cache);
      } else if (request.isRemove()) {
        result = remove(request, cache);
      } else if (request.isSelect()) {
        result = select(request, cache);
      }
      if (logger.isDebugEnabled()) {
        logger.debug(""Result is {}"", result);
      }
      functionContext.getResultSender().lastResult(result);
    } catch (Exception e) {
      logger.info(""Exception occurred:"", e);
      functionContext.getResultSender().sendException(e);
    }
  }",True
"  public void execute(FunctionContext functionContext) {
    try {
      InternalCache cache =
          ((InternalCache) functionContext.getCache()).getCacheForProcessingClientRequests();
      DataCommandRequest request = (DataCommandRequest) functionContext.getArguments();
      if (logger.isDebugEnabled()) {
        logger.debug(""Executing function : \n{}\n on member {}"", request,
            System.getProperty(""memberName""));
      }
      DataCommandResult result = null;
      if (request.isGet()) {
        result = get(request, cache);
      } else if (request.isLocateEntry()) {
        result = locateEntry(request, cache);
      } else if (request.isPut()) {
        result = put(request, cache);
      } else if (request.isRemove()) {
        result = remove(request, cache);
      } else if (request.isSelect()) {
        result = select(request, cache);
      }
      if (logger.isDebugEnabled()) {
        logger.debug(""Result is {}"", result);
      }
      functionContext.getResultSender().lastResult(result);
    } catch (Exception e) {
      logger.info(""Exception occurred:"", e);
      functionContext.getResultSender().sendException(e);
    }
  }",False
"  public CliFunctionResult executeFunction(FunctionContext context) {
    RegionConfig.Index indexInfo = (RegionConfig.Index) context.getArguments();
    String memberId = null;

    CliFunctionResult result;
    try {
      Cache cache = context.getCache();
      memberId = cache.getDistributedSystem().getDistributedMember().getId();
      QueryService queryService = cache.getQueryService();
      String indexName = indexInfo.getName();
      String regionPath = indexInfo.getFromClause();

      if (regionPath != null && !regionPath.isEmpty()) {
        Region<?, ?> region = cache.getRegion(regionPath);

        if (region != null) {
          if (indexName == null || indexName.isEmpty()) {
            queryService.removeIndexes(region);
            result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
                ""Destroyed all indexes on region "" + regionPath);
          } else {
            Index index = queryService.getIndex(region, indexName);

            if (index != null) {
              queryService.removeIndex(index);
              result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
                  ""Destroyed index "" + indexName + "" on region "" + regionPath);
            } else {
              result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.IGNORABLE,
                  CliStrings.format(CliStrings.DESTROY_INDEX__INDEX__NOT__FOUND, indexName));
            }
          }
        } else {
          result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.ERROR,
              CliStrings.format(CliStrings.DESTROY_INDEX__REGION__NOT__FOUND, regionPath));
        }
      } else {
        if (indexName == null || indexName.isEmpty()) {
          queryService.removeIndexes();
          result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
              ""Destroyed all indexes"");
        } else {
          boolean indexRemoved = removeIndexByName(indexName, queryService);
          if (indexRemoved) {
            result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
                ""Destroyed index "" + indexName);
          } else {
            result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.IGNORABLE,
                CliStrings.format(CliStrings.DESTROY_INDEX__INDEX__NOT__FOUND, indexName));
          }
        }
      }
    } catch (CacheClosedException e) {
      result = new CliFunctionResult(memberId, e, e.getMessage());
    } catch (Exception e) {
      result = new CliFunctionResult(memberId, e, e.getMessage());
    }

    return result;
  }",True
"  public CliFunctionResult executeFunction(FunctionContext context) {
    RegionConfig.Index indexInfo = (RegionConfig.Index) context.getArguments();
    String memberId = null;

    CliFunctionResult result;
    try {
      Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
      memberId = cache.getDistributedSystem().getDistributedMember().getId();
      QueryService queryService = cache.getQueryService();
      String indexName = indexInfo.getName();
      String regionPath = indexInfo.getFromClause();

      if (regionPath != null && !regionPath.isEmpty()) {
        Region<?, ?> region = cache.getRegion(regionPath);

        if (region != null) {
          if (indexName == null || indexName.isEmpty()) {
            queryService.removeIndexes(region);
            result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
                ""Destroyed all indexes on region "" + regionPath);
          } else {
            Index index = queryService.getIndex(region, indexName);

            if (index != null) {
              queryService.removeIndex(index);
              result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
                  ""Destroyed index "" + indexName + "" on region "" + regionPath);
            } else {
              result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.IGNORABLE,
                  CliStrings.format(CliStrings.DESTROY_INDEX__INDEX__NOT__FOUND, indexName));
            }
          }
        } else {
          result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.ERROR,
              CliStrings.format(CliStrings.DESTROY_INDEX__REGION__NOT__FOUND, regionPath));
        }
      } else {
        if (indexName == null || indexName.isEmpty()) {
          queryService.removeIndexes();
          result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
              ""Destroyed all indexes"");
        } else {
          boolean indexRemoved = removeIndexByName(indexName, queryService);
          if (indexRemoved) {
            result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.OK,
                ""Destroyed index "" + indexName);
          } else {
            result = new CliFunctionResult(memberId, CliFunctionResult.StatusState.IGNORABLE,
                CliStrings.format(CliStrings.DESTROY_INDEX__INDEX__NOT__FOUND, indexName));
          }
        }
      }
    } catch (CacheClosedException e) {
      result = new CliFunctionResult(memberId, e, e.getMessage());
    } catch (Exception e) {
      result = new CliFunctionResult(memberId, e, e.getMessage());
    }

    return result;
  }",False
"  public void execute(FunctionContext context) {
    final String[] args = (String[]) context.getArguments();
    if (args.length < 3) {
      throw new IllegalStateException(
          ""Arguments length does not match required length. Export command may have been sent from incompatible older version"");
    }
    final String regionName = args[0];
    final String fileName = args[1];
    final boolean parallel = Boolean.parseBoolean(args[2]);

    try {
      Cache cache = context.getCache();
      Region<?, ?> region = cache.getRegion(regionName);
      String hostName = cache.getDistributedSystem().getDistributedMember().getHost();
      if (region != null) {
        RegionSnapshotService<?, ?> snapshotService = region.getSnapshotService();
        final File exportFile = new File(fileName);
        if (parallel) {
          SnapshotOptions options = new SnapshotOptionsImpl<>().setParallelMode(true);
          snapshotService.save(exportFile, SnapshotFormat.GEMFIRE, options);
        } else {
          snapshotService.save(exportFile, SnapshotFormat.GEMFIRE);
        }
        String successMessage = CliStrings.format(CliStrings.EXPORT_DATA__SUCCESS__MESSAGE,
            regionName, exportFile.getCanonicalPath(), hostName);
        context.getResultSender().lastResult(successMessage);
      } else {
        throw new IllegalArgumentException(
            CliStrings.format(CliStrings.REGION_NOT_FOUND, regionName));
      }

    } catch (Exception e) {
      context.getResultSender().sendException(e);
    }
  }",True
"  public void execute(FunctionContext context) {
    final String[] args = (String[]) context.getArguments();
    if (args.length < 3) {
      throw new IllegalStateException(
          ""Arguments length does not match required length. Export command may have been sent from incompatible older version"");
    }
    final String regionName = args[0];
    final String fileName = args[1];
    final boolean parallel = Boolean.parseBoolean(args[2]);

    try {
      Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
      Region<?, ?> region = cache.getRegion(regionName);
      String hostName = cache.getDistributedSystem().getDistributedMember().getHost();
      if (region != null) {
        RegionSnapshotService<?, ?> snapshotService = region.getSnapshotService();
        final File exportFile = new File(fileName);
        if (parallel) {
          SnapshotOptions options = new SnapshotOptionsImpl<>().setParallelMode(true);
          snapshotService.save(exportFile, SnapshotFormat.GEMFIRE, options);
        } else {
          snapshotService.save(exportFile, SnapshotFormat.GEMFIRE);
        }
        String successMessage = CliStrings.format(CliStrings.EXPORT_DATA__SUCCESS__MESSAGE,
            regionName, exportFile.getCanonicalPath(), hostName);
        context.getResultSender().lastResult(successMessage);
      } else {
        throw new IllegalArgumentException(
            CliStrings.format(CliStrings.REGION_NOT_FOUND, regionName));
      }

    } catch (Exception e) {
      context.getResultSender().sendException(e);
    }
  }",False
"  public static Region createOrGetExistingExportLogsRegion(boolean isInitiatingMember,
      InternalCache cache) throws IOException, ClassNotFoundException {

    Region exportLogsRegion = cache.getRegion(EXPORT_LOGS_REGION);
    if (exportLogsRegion == null) {
      AttributesFactory<String, Configuration> regionAttrsFactory = new AttributesFactory<>();
      regionAttrsFactory.setDataPolicy(DataPolicy.EMPTY);
      regionAttrsFactory.setScope(Scope.DISTRIBUTED_ACK);

      if (isInitiatingMember) {
        regionAttrsFactory.setCacheWriter(new ExportLogsCacheWriter());
      }
      InternalRegionArguments internalArgs = new InternalRegionArguments();
      internalArgs.setIsUsedForMetaRegion(true);
      exportLogsRegion =
          cache.createVMRegion(EXPORT_LOGS_REGION, regionAttrsFactory.create(), internalArgs);
    }

    return exportLogsRegion;
  }",True
"  public static Region createOrGetExistingExportLogsRegion(boolean isInitiatingMember,
      InternalCache cache) throws IOException, ClassNotFoundException {

    InternalCacheForClientAccess cacheForClientAccess = cache.getCacheForProcessingClientRequests();
    Region exportLogsRegion = cacheForClientAccess.getInternalRegion(EXPORT_LOGS_REGION);
    if (exportLogsRegion == null) {
      AttributesFactory<String, Configuration> regionAttrsFactory = new AttributesFactory<>();
      regionAttrsFactory.setDataPolicy(DataPolicy.EMPTY);
      regionAttrsFactory.setScope(Scope.DISTRIBUTED_ACK);

      if (isInitiatingMember) {
        regionAttrsFactory.setCacheWriter(new ExportLogsCacheWriter());
      }
      InternalRegionArguments internalArgs = new InternalRegionArguments();
      internalArgs.setIsUsedForMetaRegion(true);
      exportLogsRegion =
          cacheForClientAccess.createInternalRegion(EXPORT_LOGS_REGION, regionAttrsFactory.create(),
              internalArgs);
    }

    return exportLogsRegion;
  }",False
"  public static void destroyExportLogsRegion(InternalCache cache) {
    Region exportLogsRegion = cache.getRegion(EXPORT_LOGS_REGION);
    if (exportLogsRegion == null) {
      return;
    }
    exportLogsRegion.destroyRegion();
  }",True
"  public static void destroyExportLogsRegion(InternalCache cache) {
    Region exportLogsRegion =
        cache.getCacheForProcessingClientRequests().getInternalRegion(EXPORT_LOGS_REGION);
    if (exportLogsRegion == null) {
      return;
    }
    exportLogsRegion.destroyRegion();
  }",False
"  public void execute(FunctionContext context) {
    String regionPath = (String) context.getArguments();
    try {
      Cache cache = context.getCache();
      Region<?, ?> region = cache.getRegion(regionPath);

      if (region != null) {
        String memberName = cache.getDistributedSystem().getDistributedMember().getName();
        RegionDescriptionPerMember regionDescription =
            new RegionDescriptionPerMember(region, memberName);
        context.getResultSender().lastResult(regionDescription);
      } else {
        context.getResultSender().lastResult(null);
      }
    } catch (Exception e) {
      context.getResultSender().sendException(e);
    }
  }",True
"  public void execute(FunctionContext context) {
    String regionPath = (String) context.getArguments();
    try {
      Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
      Region<?, ?> region = cache.getRegion(regionPath);

      if (region != null) {
        String memberName = cache.getDistributedSystem().getDistributedMember().getName();
        RegionDescriptionPerMember regionDescription =
            new RegionDescriptionPerMember(region, memberName);
        context.getResultSender().lastResult(regionDescription);
      } else {
        context.getResultSender().lastResult(null);
      }
    } catch (Exception e) {
      context.getResultSender().sendException(e);
    }
  }",False
"  public void execute(FunctionContext context) {
    final Object[] args = (Object[]) context.getArguments();
    if (args.length < 4) {
      throw new IllegalStateException(
          ""Arguments length does not match required length. Import command may have been sent from incompatible older version"");
    }
    final String regionName = (String) args[0];
    final String importFileName = (String) args[1];
    final boolean invokeCallbacks = (boolean) args[2];
    final boolean parallel = (boolean) args[3];

    try {
      final Cache cache = context.getCache();
      final Region<?, ?> region = cache.getRegion(regionName);
      final String hostName = cache.getDistributedSystem().getDistributedMember().getHost();
      if (region != null) {
        RegionSnapshotService<?, ?> snapshotService = region.getSnapshotService();
        SnapshotOptions options = snapshotService.createOptions();
        options.invokeCallbacks(invokeCallbacks);
        options.setParallelMode(parallel);
        File importFile = new File(importFileName);
        snapshotService.load(new File(importFileName), SnapshotFormat.GEMFIRE, options);
        String successMessage = CliStrings.format(CliStrings.IMPORT_DATA__SUCCESS__MESSAGE,
            importFile.getCanonicalPath(), hostName, regionName);
        context.getResultSender().lastResult(successMessage);
      } else {
        throw new IllegalArgumentException(
            CliStrings.format(CliStrings.REGION_NOT_FOUND, regionName));
      }

    } catch (Exception e) {
      context.getResultSender().sendException(e);
    }
  }",True
"  public void execute(FunctionContext context) {
    final Object[] args = (Object[]) context.getArguments();
    if (args.length < 4) {
      throw new IllegalStateException(
          ""Arguments length does not match required length. Import command may have been sent from incompatible older version"");
    }
    final String regionName = (String) args[0];
    final String importFileName = (String) args[1];
    final boolean invokeCallbacks = (boolean) args[2];
    final boolean parallel = (boolean) args[3];

    try {
      final Cache cache =
          ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
      final Region<?, ?> region = cache.getRegion(regionName);
      final String hostName = cache.getDistributedSystem().getDistributedMember().getHost();
      if (region != null) {
        RegionSnapshotService<?, ?> snapshotService = region.getSnapshotService();
        SnapshotOptions options = snapshotService.createOptions();
        options.invokeCallbacks(invokeCallbacks);
        options.setParallelMode(parallel);
        File importFile = new File(importFileName);
        snapshotService.load(new File(importFileName), SnapshotFormat.GEMFIRE, options);
        String successMessage = CliStrings.format(CliStrings.IMPORT_DATA__SUCCESS__MESSAGE,
            importFile.getCanonicalPath(), hostName, regionName);
        context.getResultSender().lastResult(successMessage);
      } else {
        throw new IllegalArgumentException(
            CliStrings.format(CliStrings.REGION_NOT_FOUND, regionName));
      }

    } catch (Exception e) {
      context.getResultSender().sendException(e);
    }
  }",False
"  public void execute(FunctionContext context) {
    ResultSender<Object> resultSender = context.getResultSender();

    Cache cache = context.getCache();
    String memberNameOrId =
        CliUtil.getMemberNameOrId(cache.getDistributedSystem().getDistributedMember());

    RegionFunctionArgs regionAlterArgs = (RegionFunctionArgs) context.getArguments();
    try {
      Region<?, ?> alteredRegion = alterRegion(cache, regionAlterArgs);
      XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, ""name"", alteredRegion.getName());
      resultSender.lastResult(new CliFunctionResult(memberNameOrId, xmlEntity,
          CliStrings.format(CliStrings.ALTER_REGION__MSG__REGION_0_ALTERED_ON_1,
              new Object[] {alteredRegion.getFullPath(), memberNameOrId})));

    } catch (IllegalStateException e) {
      logger.error(e.getMessage(), e);

      resultSender.lastResult(new CliFunctionResult(memberNameOrId, false, e.getMessage()));
    } catch (IllegalArgumentException e) {
      logger.error(e.getMessage(), e);

      resultSender.lastResult(new CliFunctionResult(memberNameOrId, false, e.getMessage()));
    } catch (VirtualMachineError e) {
      SystemFailure.initiateFailure(e);
      throw e;

    } catch (Throwable th) {
      SystemFailure.checkFailure();
      logger.error(th.getMessage(), th);

      String exceptionMsg = th.getMessage();
      if (exceptionMsg == null) {
        exceptionMsg = ExceptionUtils.getStackTrace(th);
      }
      resultSender.lastResult(new CliFunctionResult(memberNameOrId, false, exceptionMsg));
    }
  }",True
"  public void execute(FunctionContext context) {
    ResultSender<Object> resultSender = context.getResultSender();

    Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
    String memberNameOrId =
        CliUtil.getMemberNameOrId(cache.getDistributedSystem().getDistributedMember());

    RegionFunctionArgs regionAlterArgs = (RegionFunctionArgs) context.getArguments();
    try {
      Region<?, ?> alteredRegion = alterRegion(cache, regionAlterArgs);
      XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, ""name"", alteredRegion.getName());
      resultSender.lastResult(new CliFunctionResult(memberNameOrId, xmlEntity,
          CliStrings.format(CliStrings.ALTER_REGION__MSG__REGION_0_ALTERED_ON_1,
              new Object[] {alteredRegion.getFullPath(), memberNameOrId})));

    } catch (IllegalStateException e) {
      logger.error(e.getMessage(), e);

      resultSender.lastResult(new CliFunctionResult(memberNameOrId, false, e.getMessage()));
    } catch (IllegalArgumentException e) {
      logger.error(e.getMessage(), e);

      resultSender.lastResult(new CliFunctionResult(memberNameOrId, false, e.getMessage()));
    } catch (VirtualMachineError e) {
      SystemFailure.initiateFailure(e);
      throw e;

    } catch (Throwable th) {
      SystemFailure.checkFailure();
      logger.error(th.getMessage(), th);

      String exceptionMsg = th.getMessage();
      if (exceptionMsg == null) {
        exceptionMsg = ExceptionUtils.getStackTrace(th);
      }
      resultSender.lastResult(new CliFunctionResult(memberNameOrId, false, exceptionMsg));
    }
  }",False
"  public void execute(FunctionContext context) {
    ResultSender<Object> resultSender = context.getResultSender();

    Cache cache = context.getCache();
    String memberNameOrId = context.getMemberName();

    RegionFunctionArgs regionCreateArgs = (RegionFunctionArgs) context.getArguments();

    if (regionCreateArgs.isIfNotExists()) {
      Region<Object, Object> region = cache.getRegion(regionCreateArgs.getRegionPath());
      if (region != null) {
        resultSender.lastResult(new CliFunctionResult(memberNameOrId, true,
            CliStrings.format(
                CliStrings.CREATE_REGION__MSG__SKIPPING_0_REGION_PATH_1_ALREADY_EXISTS,
                memberNameOrId, regionCreateArgs.getRegionPath())));
        return;
      }
    }

    try {
      Region<?, ?> createdRegion = createRegion(cache, regionCreateArgs);
      XmlEntity xmlEntity = getXmlEntityForRegion(createdRegion);

      resultSender.lastResult(new CliFunctionResult(memberNameOrId, xmlEntity,
          CliStrings.format(CliStrings.CREATE_REGION__MSG__REGION_0_CREATED_ON_1,
              createdRegion.getFullPath(), memberNameOrId)));
    } catch (IllegalStateException e) {
      String exceptionMsg = e.getMessage();
      String localizedString =
          ""Only regions with persistence or overflow to disk can specify DiskStore"";
      if (localizedString.equals(e.getMessage())) {
        exceptionMsg = exceptionMsg + "" ""
            + CliStrings.format(CliStrings.CREATE_REGION__MSG__USE_ONE_OF_THESE_SHORTCUTS_0,
                new Object[] {String.valueOf(RegionCommandsUtils.PERSISTENT_OVERFLOW_SHORTCUTS)});
      }
      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, null/* do not log */));
    } catch (IllegalArgumentException e) {
      resultSender.lastResult(handleException(memberNameOrId, e.getMessage(), e));
    } catch (RegionExistsException e) {
      String exceptionMsg =
          CliStrings.format(CliStrings.CREATE_REGION__MSG__REGION_PATH_0_ALREADY_EXISTS_ON_1,
              regionCreateArgs.getRegionPath(), memberNameOrId);
      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, e));
    } catch (Exception e) {
      String exceptionMsg = e.getMessage();
      if (exceptionMsg == null) {
        exceptionMsg = ExceptionUtils.getStackTrace(e);
      }
      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, e));
    }
  }",True
"  public void execute(FunctionContext context) {
    ResultSender<Object> resultSender = context.getResultSender();

    Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
    String memberNameOrId = context.getMemberName();

    RegionFunctionArgs regionCreateArgs = (RegionFunctionArgs) context.getArguments();

    if (regionCreateArgs.isIfNotExists()) {
      Region<Object, Object> region = cache.getRegion(regionCreateArgs.getRegionPath());
      if (region != null) {
        resultSender.lastResult(new CliFunctionResult(memberNameOrId, true,
            CliStrings.format(
                CliStrings.CREATE_REGION__MSG__SKIPPING_0_REGION_PATH_1_ALREADY_EXISTS,
                memberNameOrId, regionCreateArgs.getRegionPath())));
        return;
      }
    }

    try {
      Region<?, ?> createdRegion = createRegion(cache, regionCreateArgs);
      XmlEntity xmlEntity = getXmlEntityForRegion(createdRegion);

      resultSender.lastResult(new CliFunctionResult(memberNameOrId, xmlEntity,
          CliStrings.format(CliStrings.CREATE_REGION__MSG__REGION_0_CREATED_ON_1,
              createdRegion.getFullPath(), memberNameOrId)));
    } catch (IllegalStateException e) {
      String exceptionMsg = e.getMessage();
      String localizedString =
          ""Only regions with persistence or overflow to disk can specify DiskStore"";
      if (localizedString.equals(e.getMessage())) {
        exceptionMsg = exceptionMsg + "" ""
            + CliStrings.format(CliStrings.CREATE_REGION__MSG__USE_ONE_OF_THESE_SHORTCUTS_0,
                new Object[] {String.valueOf(RegionCommandsUtils.PERSISTENT_OVERFLOW_SHORTCUTS)});
      }
      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, null/* do not log */));
    } catch (IllegalArgumentException e) {
      resultSender.lastResult(handleException(memberNameOrId, e.getMessage(), e));
    } catch (RegionExistsException e) {
      String exceptionMsg =
          CliStrings.format(CliStrings.CREATE_REGION__MSG__REGION_PATH_0_ALREADY_EXISTS_ON_1,
              regionCreateArgs.getRegionPath(), memberNameOrId);
      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, e));
    } catch (Exception e) {
      String exceptionMsg = e.getMessage();
      if (exceptionMsg == null) {
        exceptionMsg = ExceptionUtils.getStackTrace(e);
      }
      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, e));
    }
  }",False
"  public void execute(FunctionContext context) {
    String regionPath = null;
    String memberName = context.getMemberName();

    try {
      String functionId = context.getFunctionId();
      Object arguments = context.getArguments();

      if (!getId().equals(functionId) || arguments == null) {
        context.getResultSender().lastResult(new CliFunctionResult("""", false,
            ""Function Id mismatch or arguments is not available.""));
        return;
      }

      regionPath = (String) arguments;
      Cache cache = context.getCache();
      Region<?, ?> region = cache.getRegion(regionPath);
      // the region is already destroyed by another member
      if (region == null) {
        context.getResultSender().lastResult(new CliFunctionResult(memberName, true,
            String.format(""Region '%s' already destroyed"", regionPath)));
        return;
      }

      region.destroyRegion();

      String regionName =
          regionPath.startsWith(Region.SEPARATOR) ? regionPath.substring(1) : regionPath;
      XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, ""name"", regionName);
      context.getResultSender().lastResult(new CliFunctionResult(memberName, xmlEntity,
          String.format(""Region '%s' destroyed successfully"", regionPath)));

    } catch (IllegalStateException ex) {
      // user is trying to destroy something that can't destroyed, like co-location
      context.getResultSender()
          .lastResult(new CliFunctionResult(memberName, false, ex.getMessage()));
    } catch (RegionDestroyedException ex) {
      context.getResultSender().lastResult(new CliFunctionResult(memberName, true,
          String.format(""Region '%s' already destroyed"", regionPath)));
    } catch (Exception ex) {
      LogService.getLogger().error(ex.getMessage(), ex);
      context.getResultSender().lastResult(new CliFunctionResult(memberName, ex, ex.getMessage()));
    }
  }",True
"  public void execute(FunctionContext context) {
    String regionPath = null;
    String memberName = context.getMemberName();

    try {
      String functionId = context.getFunctionId();
      Object arguments = context.getArguments();

      if (!getId().equals(functionId) || arguments == null) {
        context.getResultSender().lastResult(new CliFunctionResult("""", false,
            ""Function Id mismatch or arguments is not available.""));
        return;
      }

      regionPath = (String) arguments;
      Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
      Region<?, ?> region = cache.getRegion(regionPath);
      // the region is already destroyed by another member
      if (region == null) {
        context.getResultSender().lastResult(new CliFunctionResult(memberName, true,
            String.format(""Region '%s' already destroyed"", regionPath)));
        return;
      }

      region.destroyRegion();

      String regionName =
          regionPath.startsWith(Region.SEPARATOR) ? regionPath.substring(1) : regionPath;
      XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, ""name"", regionName);
      context.getResultSender().lastResult(new CliFunctionResult(memberName, xmlEntity,
          String.format(""Region '%s' destroyed successfully"", regionPath)));

    } catch (IllegalStateException ex) {
      // user is trying to destroy something that can't destroyed, like co-location
      context.getResultSender()
          .lastResult(new CliFunctionResult(memberName, false, ex.getMessage()));
    } catch (RegionDestroyedException ex) {
      context.getResultSender().lastResult(new CliFunctionResult(memberName, true,
          String.format(""Region '%s' already destroyed"", regionPath)));
    } catch (Exception ex) {
      LogService.getLogger().error(ex.getMessage(), ex);
      context.getResultSender().lastResult(new CliFunctionResult(memberName, ex, ex.getMessage()));
    }
  }",False
"  public void execute(FunctionContext<Object[]> context) {
    Cache cache = context.getCache();
    DistributedMember member = cache.getDistributedSystem().getDistributedMember();

    String[] functionArgs = null;
    Object[] args = context.getArguments();
    if (args == null) {
      context.getResultSender().lastResult(new CliFunctionResult(context.getMemberName(), ERROR,
          CliStrings.EXECUTE_FUNCTION__MSG__COULD_NOT_RETRIEVE_ARGUMENTS));
      return;
    }

    String functionId = ((String) args[0]);
    String filterString = ((String) args[1]);
    String resultCollectorName = ((String) args[2]);
    String argumentsString = ((String) args[3]);
    String onRegion = ((String) args[4]);
    Properties credentials = (Properties) args[5];

    SecurityService securityService = ((InternalCache) context.getCache()).getSecurityService();
    boolean loginNeeded = false;
    try {
      // if the function is executed on a server with jmx-manager that user is already logged into
      // then we do not need to do login/logout here.
      Subject subject = securityService.getSubject();
      loginNeeded = subject == null || !subject.isAuthenticated();
    } catch (AuthenticationRequiredException e) {
      loginNeeded = true;
    }

    boolean loginSuccessful = false;
    try {
      if (loginNeeded) {
        securityService.login(credentials);
        loginSuccessful = true;
      }

      if (argumentsString != null && argumentsString.length() > 0) {
        functionArgs = argumentsString.split("","");
      }
      Set<String> filters = new HashSet<>();
      ResultCollector resultCollectorInstance = null;
      if (resultCollectorName != null && resultCollectorName.length() > 0) {
        resultCollectorInstance = (ResultCollector) ClassPathLoader.getLatest()
            .forName(resultCollectorName).newInstance();
      }
      if (filterString != null && filterString.length() > 0) {
        filters = Arrays.stream(filterString.split("","")).collect(Collectors.toSet());
      }

      Function<?> function = FunctionService.getFunction(functionId);
      if (function == null) {
        context.getResultSender()
            .lastResult(new CliFunctionResult(context.getMemberName(), ERROR,
                (CliStrings.format(
                    CliStrings.EXECUTE_FUNCTION__MSG__DOES_NOT_HAVE_FUNCTION_0_REGISTERED,
                    functionId))));
        return;
      }

      // security check
      function.getRequiredPermissions(onRegion, functionArgs).forEach(securityService::authorize);

      Execution execution = null;
      if (onRegion != null && onRegion.length() > 0) {
        Region region = cache.getRegion(onRegion);
        if (region == null) {
          context.getResultSender().lastResult(
              new CliFunctionResult(context.getMemberName(), ERROR, onRegion + "" does not exist""));
          return;
        }
        execution = FunctionService.onRegion(region);
      } else {
        execution = FunctionService.onMember(member);
      }

      if (execution == null) {
        context.getResultSender()
            .lastResult(new CliFunctionResult(context.getMemberName(), ERROR,
                CliStrings.format(
                    CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_EXECUTING_0_ON_MEMBER_1_ON_REGION_2_DETAILS_3,
                    functionId, member.getId(), onRegion,
                    CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_RETRIEVING_EXECUTOR)));
        return;
      }

      if (resultCollectorInstance != null) {
        execution = execution.withCollector(resultCollectorInstance);
      }

      if (functionArgs != null && functionArgs.length > 0) {
        execution = execution.setArguments(functionArgs);
      }
      if (filters.size() > 0) {
        execution = execution.withFilter(filters);
      }

      List<Object> results = (List<Object>) execution.execute(function.getId()).getResult();
      List<String> resultMessage = new ArrayList<>();
      boolean functionSuccess = true;

      if (results != null) {
        for (Object resultObj : results) {
          if (resultObj != null) {
            if (resultObj instanceof Exception) {
              resultMessage.add(((Exception) resultObj).getMessage());
              functionSuccess = false;
            } else {
              resultMessage.add(resultObj.toString());
            }
          }
        }
      }
      context.getResultSender().lastResult(new CliFunctionResult(context.getMemberName(),
          functionSuccess, resultMessage.toString()));

    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
      context.getResultSender()
          .lastResult(new CliFunctionResult(context.getMemberName(), false,
              CliStrings.format(
                  CliStrings.EXECUTE_FUNCTION__MSG__RESULT_COLLECTOR_0_NOT_FOUND_ERROR_1,
                  resultCollectorName, e.getMessage())));
    } catch (Exception e) {
      logger.error(""error executing function "" + functionId, e);
      context.getResultSender().lastResult(
          new CliFunctionResult(context.getMemberName(), false, ""Exception: "" + e.getMessage()));
    } finally {
      if (loginSuccessful) {
        securityService.logout();
      }
    }
  }",True
"  public void execute(FunctionContext<Object[]> context) {
    Cache cache = ((InternalCache) context.getCache()).getCacheForProcessingClientRequests();
    DistributedMember member = cache.getDistributedSystem().getDistributedMember();

    String[] functionArgs = null;
    Object[] args = context.getArguments();
    if (args == null) {
      context.getResultSender().lastResult(new CliFunctionResult(context.getMemberName(), ERROR,
          CliStrings.EXECUTE_FUNCTION__MSG__COULD_NOT_RETRIEVE_ARGUMENTS));
      return;
    }

    String functionId = ((String) args[0]);
    String filterString = ((String) args[1]);
    String resultCollectorName = ((String) args[2]);
    String argumentsString = ((String) args[3]);
    String onRegion = ((String) args[4]);
    Properties credentials = (Properties) args[5];

    SecurityService securityService = ((InternalCache) context.getCache()).getSecurityService();
    boolean loginNeeded = false;
    try {
      // if the function is executed on a server with jmx-manager that user is already logged into
      // then we do not need to do login/logout here.
      Subject subject = securityService.getSubject();
      loginNeeded = subject == null || !subject.isAuthenticated();
    } catch (AuthenticationRequiredException e) {
      loginNeeded = true;
    }

    boolean loginSuccessful = false;
    try {
      if (loginNeeded) {
        securityService.login(credentials);
        loginSuccessful = true;
      }

      if (argumentsString != null && argumentsString.length() > 0) {
        functionArgs = argumentsString.split("","");
      }
      Set<String> filters = new HashSet<>();
      ResultCollector resultCollectorInstance = null;
      if (resultCollectorName != null && resultCollectorName.length() > 0) {
        resultCollectorInstance = (ResultCollector) ClassPathLoader.getLatest()
            .forName(resultCollectorName).newInstance();
      }
      if (filterString != null && filterString.length() > 0) {
        filters = Arrays.stream(filterString.split("","")).collect(Collectors.toSet());
      }

      Function<?> function = FunctionService.getFunction(functionId);
      if (function == null) {
        context.getResultSender()
            .lastResult(new CliFunctionResult(context.getMemberName(), ERROR,
                (CliStrings.format(
                    CliStrings.EXECUTE_FUNCTION__MSG__DOES_NOT_HAVE_FUNCTION_0_REGISTERED,
                    functionId))));
        return;
      }

      // security check
      function.getRequiredPermissions(onRegion, functionArgs).forEach(securityService::authorize);

      Execution execution = null;
      if (onRegion != null && onRegion.length() > 0) {
        Region region = cache.getRegion(onRegion);
        if (region == null) {
          context.getResultSender().lastResult(
              new CliFunctionResult(context.getMemberName(), ERROR, onRegion + "" does not exist""));
          return;
        }
        execution = FunctionService.onRegion(region);
      } else {
        execution = FunctionService.onMember(member);
      }

      if (execution == null) {
        context.getResultSender()
            .lastResult(new CliFunctionResult(context.getMemberName(), ERROR,
                CliStrings.format(
                    CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_EXECUTING_0_ON_MEMBER_1_ON_REGION_2_DETAILS_3,
                    functionId, member.getId(), onRegion,
                    CliStrings.EXECUTE_FUNCTION__MSG__ERROR_IN_RETRIEVING_EXECUTOR)));
        return;
      }

      if (resultCollectorInstance != null) {
        execution = execution.withCollector(resultCollectorInstance);
      }

      if (functionArgs != null && functionArgs.length > 0) {
        execution = execution.setArguments(functionArgs);
      }
      if (filters.size() > 0) {
        execution = execution.withFilter(filters);
      }

      List<Object> results = (List<Object>) execution.execute(function.getId()).getResult();
      List<String> resultMessage = new ArrayList<>();
      boolean functionSuccess = true;

      if (results != null) {
        for (Object resultObj : results) {
          if (resultObj != null) {
            if (resultObj instanceof Exception) {
              resultMessage.add(((Exception) resultObj).getMessage());
              functionSuccess = false;
            } else {
              resultMessage.add(resultObj.toString());
            }
          }
        }
      }
      context.getResultSender().lastResult(new CliFunctionResult(context.getMemberName(),
          functionSuccess, resultMessage.toString()));

    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
      context.getResultSender()
          .lastResult(new CliFunctionResult(context.getMemberName(), false,
              CliStrings.format(
                  CliStrings.EXECUTE_FUNCTION__MSG__RESULT_COLLECTOR_0_NOT_FOUND_ERROR_1,
                  resultCollectorName, e.getMessage())));
    } catch (Exception e) {
      logger.error(""error executing function "" + functionId, e);
      context.getResultSender().lastResult(
          new CliFunctionResult(context.getMemberName(), false, ""Exception: "" + e.getMessage()));
    } finally {
      if (loginSuccessful) {
        securityService.logout();
      }
    }
  }",False
"  private void logException(Exception e) {
    Cache cache = CacheFactory.getAnyInstance();
    LogWriter logger = cache.getLogger();
    logger.warning(""Error parsing command mode descriptor"", e);
  }",True
"  private void logException(Exception e) {
    logger.warn(""Error parsing command mode descriptor"", e);
  }",False
"  private static CacheProvider createDefaultCacheProvider() {
    return () -> (InternalCache) CacheFactory.getAnyInstance();
  }",True
"  private static CacheProvider createDefaultCacheProvider() {
    return () -> ((InternalCache) CacheFactory.getAnyInstance())
        .getCacheForProcessingClientRequests();
  }",False
"  public void execute(FunctionContext context) {
    InternalCache cache = GemFireCacheImpl.getInstance();

    Set<String> regions =
        cache.getApplicationRegions().stream().map(InternalRegion::getName).collect(toSet());

    context.getResultSender().lastResult(regions);
  }",True
"  public void execute(FunctionContext context) {
    InternalCache cache = (InternalCache) context.getCache();

    Set<String> regions =
        cache.getApplicationRegions().stream().map(InternalRegion::getName).collect(toSet());

    context.getResultSender().lastResult(regions);
  }",False
"  public void testTotalEstimateSizeExceedsUserSpecifiedValue() throws Exception {
    final InternalCache mockCache = mock(InternalCache.class);
    final ExportLogsCommand realCmd = new ExportLogsCommand();
    ExportLogsCommand spyCmd = spy(realCmd);

    String start = null;
    String end = null;
    String logLevel = null;
    boolean onlyLogLevel = false;
    boolean logsOnly = false;
    boolean statsOnly = false;

    InternalDistributedMember member1 = new InternalDistributedMember(""member1"", 12345);
    InternalDistributedMember member2 = new InternalDistributedMember(""member2"", 98765);
    member1.getNetMember().setName(""member1"");
    member2.getNetMember().setName(""member2"");
    Set<DistributedMember> testMembers = new HashSet<>();
    testMembers.add(member1);
    testMembers.add(member2);

    ResultCollector testResults1 = new CustomCollector();
    testResults1.addResult(member1, 75 * MEGABYTE);
    ResultCollector testResults2 = new CustomCollector();
    testResults2.addResult(member2, 60 * MEGABYTE);

    doReturn(mockCache).when(spyCmd).getCache();
    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
    doReturn(testResults1).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
    doReturn(testResults2).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member2));
    doReturn(GIGABYTE).when(spyCmd).getLocalDiskAvailable();

    CommandResult res = (CommandResult) spyCmd.exportLogs(""working dir"", null, null, logLevel,
        onlyLogLevel, false, start, end, logsOnly, statsOnly, ""125m"");
    assertThat(res.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(res.toJson()).contains(
        ""Estimated exported logs expanded file size = 141557760, file-size-limit = 131072000"");
  }",True
"  public void testTotalEstimateSizeExceedsUserSpecifiedValue() throws Exception {
    final InternalCache mockCache = mock(InternalCache.class);
    final InternalCacheForClientAccess mockCacheFilter = mock(InternalCacheForClientAccess.class);
    when(mockCache.getCacheForProcessingClientRequests()).thenReturn(mockCacheFilter);
    final ExportLogsCommand realCmd = new ExportLogsCommand();
    ExportLogsCommand spyCmd = spy(realCmd);

    String start = null;
    String end = null;
    String logLevel = null;
    boolean onlyLogLevel = false;
    boolean logsOnly = false;
    boolean statsOnly = false;

    InternalDistributedMember member1 = new InternalDistributedMember(""member1"", 12345);
    InternalDistributedMember member2 = new InternalDistributedMember(""member2"", 98765);
    member1.getNetMember().setName(""member1"");
    member2.getNetMember().setName(""member2"");
    Set<DistributedMember> testMembers = new HashSet<>();
    testMembers.add(member1);
    testMembers.add(member2);

    ResultCollector testResults1 = new CustomCollector();
    testResults1.addResult(member1, 75 * MEGABYTE);
    ResultCollector testResults2 = new CustomCollector();
    testResults2.addResult(member2, 60 * MEGABYTE);

    doReturn(mockCache).when(spyCmd).getCache();
    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
    doReturn(testResults1).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
    doReturn(testResults2).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member2));
    doReturn(GIGABYTE).when(spyCmd).getLocalDiskAvailable();

    CommandResult res = (CommandResult) spyCmd.exportLogs(""working dir"", null, null, logLevel,
        onlyLogLevel, false, start, end, logsOnly, statsOnly, ""125m"");
    assertThat(res.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(res.toJson()).contains(
        ""Estimated exported logs expanded file size = 141557760, file-size-limit = 131072000"");
  }",False
"  public void testTotalEstimateSizeExceedsLocatorAvailableDisk() throws Exception {
    final InternalCache mockCache = mock(InternalCache.class);
    final ExportLogsCommand realCmd = new ExportLogsCommand();
    ExportLogsCommand spyCmd = spy(realCmd);

    String start = null;
    String end = null;
    String logLevel = null;
    boolean onlyLogLevel = false;
    boolean logsOnly = false;
    boolean statsOnly = false;

    InternalDistributedMember member1 = new InternalDistributedMember(""member1"", 12345);
    InternalDistributedMember member2 = new InternalDistributedMember(""member2"", 98765);
    member1.getNetMember().setName(""member1"");
    member2.getNetMember().setName(""member2"");
    Set<DistributedMember> testMembers = new HashSet<>();
    testMembers.add(member1);
    testMembers.add(member2);

    ResultCollector testResults1 = new CustomCollector();
    testResults1.addResult(member1, 75 * MEGABYTE);
    ResultCollector testResults2 = new CustomCollector();
    testResults2.addResult(member2, 60 * MEGABYTE);

    doReturn(mockCache).when(spyCmd).getCache();
    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
    doReturn(testResults1).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
    doReturn(testResults2).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member2));
    doReturn(10 * MEGABYTE).when(spyCmd).getLocalDiskAvailable();

    CommandResult res = (CommandResult) spyCmd.exportLogs(""working dir"", null, null, logLevel,
        onlyLogLevel, false, start, end, logsOnly, statsOnly, ""125m"");
    assertThat(res.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(res.toJson())
        .contains(""Estimated logs size will exceed the available disk space on the locator"");
  }",True
"  public void testTotalEstimateSizeExceedsLocatorAvailableDisk() throws Exception {
    final InternalCache mockCache = mock(InternalCache.class);
    final InternalCacheForClientAccess mockCacheFilter = mock(InternalCacheForClientAccess.class);
    when(mockCache.getCacheForProcessingClientRequests()).thenReturn(mockCacheFilter);
    final ExportLogsCommand realCmd = new ExportLogsCommand();
    ExportLogsCommand spyCmd = spy(realCmd);

    String start = null;
    String end = null;
    String logLevel = null;
    boolean onlyLogLevel = false;
    boolean logsOnly = false;
    boolean statsOnly = false;

    InternalDistributedMember member1 = new InternalDistributedMember(""member1"", 12345);
    InternalDistributedMember member2 = new InternalDistributedMember(""member2"", 98765);
    member1.getNetMember().setName(""member1"");
    member2.getNetMember().setName(""member2"");
    Set<DistributedMember> testMembers = new HashSet<>();
    testMembers.add(member1);
    testMembers.add(member2);

    ResultCollector testResults1 = new CustomCollector();
    testResults1.addResult(member1, 75 * MEGABYTE);
    ResultCollector testResults2 = new CustomCollector();
    testResults2.addResult(member2, 60 * MEGABYTE);

    doReturn(mockCache).when(spyCmd).getCache();
    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
    doReturn(testResults1).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
    doReturn(testResults2).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member2));
    doReturn(10 * MEGABYTE).when(spyCmd).getLocalDiskAvailable();

    CommandResult res = (CommandResult) spyCmd.exportLogs(""working dir"", null, null, logLevel,
        onlyLogLevel, false, start, end, logsOnly, statsOnly, ""125m"");
    assertThat(res.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(res.toJson())
        .contains(""Estimated logs size will exceed the available disk space on the locator"");
  }",False
"  public void estimateLogSizeExceedsServerDisk() throws Exception {
    final InternalCache mockCache = mock(InternalCache.class);
    final ExportLogsCommand realCmd = new ExportLogsCommand();
    ExportLogsCommand spyCmd = spy(realCmd);

    String start = null;
    String end = null;
    String logLevel = null;
    boolean onlyLogLevel = false;
    boolean logsOnly = false;
    boolean statsOnly = false;

    InternalDistributedMember member1 = new InternalDistributedMember(""member1"", 12345);
    member1.getNetMember().setName(""member1"");
    Set<DistributedMember> testMembers = new HashSet<>();
    testMembers.add(member1);

    BytesToString bytesToString = new BytesToString();
    ResultCollector testResults1 = new CustomCollector();
    StringBuilder sb = new StringBuilder().append(""Estimated disk space required ("")
        .append(bytesToString.of(GIGABYTE)).append("") to consolidate logs on member "")
        .append(member1.getName()).append("" will exceed available disk space ("")
        .append(bytesToString.of(500 * MEGABYTE)).append("")"");
    testResults1.addResult(member1, new ManagementException(sb.toString()));

    doReturn(mockCache).when(spyCmd).getCache();
    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
    doReturn(testResults1).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));

    CommandResult res = (CommandResult) spyCmd.exportLogs(""working dir"", null, null, logLevel,
        onlyLogLevel, false, start, end, logsOnly, statsOnly, ""125m"");
    assertThat(res.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(res.toJson()).contains(
        ""Estimated disk space required (1 GB) to consolidate logs on member member1 will exceed available disk space (500 MB)"");
  }",True
"  public void estimateLogSizeExceedsServerDisk() throws Exception {
    final InternalCache mockCache = mock(InternalCache.class);
    final InternalCacheForClientAccess mockCacheFilter = mock(InternalCacheForClientAccess.class);
    when(mockCache.getCacheForProcessingClientRequests()).thenReturn(mockCacheFilter);
    final ExportLogsCommand realCmd = new ExportLogsCommand();
    ExportLogsCommand spyCmd = spy(realCmd);

    String start = null;
    String end = null;
    String logLevel = null;
    boolean onlyLogLevel = false;
    boolean logsOnly = false;
    boolean statsOnly = false;

    InternalDistributedMember member1 = new InternalDistributedMember(""member1"", 12345);
    member1.getNetMember().setName(""member1"");
    Set<DistributedMember> testMembers = new HashSet<>();
    testMembers.add(member1);

    BytesToString bytesToString = new BytesToString();
    ResultCollector testResults1 = new CustomCollector();
    StringBuilder sb = new StringBuilder().append(""Estimated disk space required ("")
        .append(bytesToString.of(GIGABYTE)).append("") to consolidate logs on member "")
        .append(member1.getName()).append("" will exceed available disk space ("")
        .append(bytesToString.of(500 * MEGABYTE)).append("")"");
    testResults1.addResult(member1, new ManagementException(sb.toString()));

    doReturn(mockCache).when(spyCmd).getCache();
    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
    doReturn(testResults1).when(spyCmd)
        .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));

    CommandResult res = (CommandResult) spyCmd.exportLogs(""working dir"", null, null, logLevel,
        onlyLogLevel, false, start, end, logsOnly, statsOnly, ""125m"");
    assertThat(res.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(res.toJson()).contains(
        ""Estimated disk space required (1 GB) to consolidate logs on member member1 will exceed available disk space (500 MB)"");
  }",False
"  public void regionAlreadyDestroyed_throwException() throws Exception {
    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
    Region region = mock(Region.class);
    when(cache.getRegion(any())).thenReturn(region);
    doThrow(mock(RegionDestroyedException.class)).when(region).destroyRegion();
    function.execute(context);

    verify(resultSender).lastResult(resultCaptor.capture());
    CliFunctionResult result = resultCaptor.getValue();

    assertThat(result.isSuccessful()).isTrue();
    assertThat(result.getThrowable()).isNull();
    assertThat(result.getMessage()).contains(""Region 'testRegion' already destroyed"");
  }",True
"  public void regionAlreadyDestroyed_throwException() throws Exception {
    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
    Region region = mock(Region.class);
    when(filterCache.getRegion(any())).thenReturn(region);
    doThrow(mock(RegionDestroyedException.class)).when(region).destroyRegion();
    function.execute(context);

    verify(resultSender).lastResult(resultCaptor.capture());
    CliFunctionResult result = resultCaptor.getValue();

    assertThat(result.isSuccessful()).isTrue();
    assertThat(result.getThrowable()).isNull();
    assertThat(result.getMessage()).contains(""Region 'testRegion' already destroyed"");
  }",False
"  public void before() {
    function = spy(RegionDestroyFunction.class);
    context = mock(FunctionContext.class);
    cache = mock(InternalCache.class);
    resultSender = mock(ResultSender.class);
    when(context.getCache()).thenReturn(cache);
    when(context.getResultSender()).thenReturn(resultSender);
    when(context.getArguments()).thenReturn(""testRegion"");
    resultCaptor = ArgumentCaptor.forClass(CliFunctionResult.class);
  }",True
"  public void before() {
    function = spy(RegionDestroyFunction.class);
    context = mock(FunctionContext.class);
    cache = mock(InternalCache.class);
    filterCache = mock(InternalCacheForClientAccess.class);
    resultSender = mock(ResultSender.class);
    when(context.getCache()).thenReturn(cache);
    when(context.getResultSender()).thenReturn(resultSender);
    when(context.getArguments()).thenReturn(""testRegion"");
    when(cache.getCacheForProcessingClientRequests()).thenReturn(filterCache);
    resultCaptor = ArgumentCaptor.forClass(CliFunctionResult.class);
  }",False
"  public void regionAlreadyDestroyed() throws Exception {
    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
    when(cache.getRegion(any())).thenReturn(null);
    function.execute(context);

    verify(resultSender).lastResult(resultCaptor.capture());
    CliFunctionResult result = resultCaptor.getValue();

    assertThat(result.isSuccessful()).isTrue();
    assertThat(result.getThrowable()).isNull();
    assertThat(result.getMessage()).contains(""Region 'testRegion' already destroyed"");
  }",True
"  public void regionAlreadyDestroyed() throws Exception {
    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
    when(filterCache.getRegion(any())).thenReturn(null);
    function.execute(context);

    verify(resultSender).lastResult(resultCaptor.capture());
    CliFunctionResult result = resultCaptor.getValue();

    assertThat(result.isSuccessful()).isTrue();
    assertThat(result.getThrowable()).isNull();
    assertThat(result.getMessage()).contains(""Region 'testRegion' already destroyed"");
  }",False
"  public void illegalStateExceptionWillNotThrowExceptionToCommand() throws Exception {
    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
    Region region = mock(Region.class);
    when(cache.getRegion(any())).thenReturn(region);
    doThrow(new IllegalStateException(""message"")).when(region).destroyRegion();

    function.execute(context);
    verify(resultSender).lastResult(resultCaptor.capture());
    CliFunctionResult result = resultCaptor.getValue();
    assertThat(result.isSuccessful()).isFalse();
    // will not populate the exception in the result, but only preserve the message
    assertThat(result.getThrowable()).isNull();
    assertThat(result.getMessage()).isEqualTo(""message"");
  }",True
"  public void illegalStateExceptionWillNotThrowExceptionToCommand() throws Exception {
    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
    Region region = mock(Region.class);
    when(filterCache.getRegion(any())).thenReturn(region);
    doThrow(new IllegalStateException(""message"")).when(region).destroyRegion();

    function.execute(context);
    verify(resultSender).lastResult(resultCaptor.capture());
    CliFunctionResult result = resultCaptor.getValue();
    assertThat(result.isSuccessful()).isFalse();
    // will not populate the exception in the result, but only preserve the message
    assertThat(result.getThrowable()).isNull();
    assertThat(result.getMessage()).isEqualTo(""message"");
  }",False
"  public void modifyInternalRegionSuperUser() {
    CommandResult result =
        gfshConnection.executeCommand(""put --key=key1 --value=value1 --region=PdxTypes"");
    assertThat(result.getStatus()).isEqualTo(Result.Status.ERROR);
    assertThat(result.getMessageFromContent()).contains(""Unauthorized"");
  }",False
"  public ResponseEntity<?> regions() {
    logger.debug(""Listing all resources (Regions) in Geode..."");
    final HttpHeaders headers = new HttpHeaders();
    headers.setLocation(toUri());
    final Set<Region<?, ?>> regions = new HashSet<>();
    for (InternalRegion region : getCache().getApplicationRegions()) {
      if (region instanceof Region) {
        regions.add(region);
      }
    } ;
    String listRegionsAsJson = JSONUtils.formulateJsonForListRegions(regions, ""regions"");
    return new ResponseEntity<>(listRegionsAsJson, headers, HttpStatus.OK);
  }",True
"  public ResponseEntity<?> regions() {
    logger.debug(""Listing all resources (Regions) in Geode..."");
    final HttpHeaders headers = new HttpHeaders();
    headers.setLocation(toUri());
    final Set<Region<?, ?>> regions = new HashSet<>();
    for (InternalRegion region : getCache().getApplicationRegions()) {
      regions.add(region);
    }
    String listRegionsAsJson = JSONUtils.formulateJsonForListRegions(regions, ""regions"");
    return new ResponseEntity<>(listRegionsAsJson, headers, HttpStatus.OK);
  }",False
